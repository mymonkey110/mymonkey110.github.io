<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael-J</title>
  
  <subtitle>一个修行路上的码农</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://michael-j.net/"/>
  <updated>2018-01-20T13:52:03.376Z</updated>
  <id>http://michael-j.net/</id>
  
  <author>
    <name>Michael Jiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蜂巢计费系统架构升级之路</title>
    <link href="http://michael-j.net/2017/12/15/%E8%9C%82%E5%B7%A2%E8%AE%A1%E8%B4%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://michael-j.net/2017/12/15/蜂巢计费系统架构升级之路/</id>
    <published>2017-12-15T06:26:26.000Z</published>
    <updated>2018-01-20T13:52:03.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>蜂巢计费系统为网易云基础服务（网易蜂巢）提供整体的计费服务，业务范围涵盖完整的产品售卖流程，包含定价、订单、支付、计费、结算、优惠、账单等主体功能，支持十几种不同产品的售卖，产品形态上贯穿了IaaS、PaaS和SaaS类别。同时，计费方式还提供了了按量、包年包月、资源包等多种方式。该项目的业务范围之广，玩法种类之多，数据要求之严注定了它将成为一个烫手的山芋，而且还是一个吃力不讨好的工作。</p><p>该项目在人员上已经几经易手，就我所知，已经换过两拨完整的开发和测试团队了，而且已经全部离职。不得不说，该项目已经变得令人谈之色变，让人敬而远之。在这样的背景下，后期接手的开发和QA不得不硬着头皮上，踩着雷过河，小心翼翼的应对着不断涌来的业务需求。随之而来的是高居不下的bug率，越来越难以维护的代码，无法扩展的架构问题，我们开始意识到这样下去是不行的。于是我们从8月份开始了漫漫的架构升级之路。</p><a id="more"></a><h2 id="重新出发"><a href="#重新出发" class="headerlink" title="重新出发"></a>重新出发</h2><p>在我们开始优化架构之前，我们重新梳理了计费系统完整的业务，得到了如下图所示的业务领域：</p><img src="/2017/12/15/蜂巢计费系统架构升级之路/biz-arch.png" title="业务领域"><p>梳理以后发现，计费系统承载了太多非计费的业务，包含订单、账单、结算和代金券等，这些业务代码散落在各处，没有严格地业务边界划分，而是“奇迹般”的融合在了一个工程里面。造成这个局面的原因在于计费系统初版设计时，根本没有考虑到这些问题，当然也不可能考虑到，而在后面逐步地迭代过程中，也未能去及时地调整架构，架构腐化不是一天内完成的。当然，这方面有部分技术的原因，也有部分人为的原因所在，因为当时负责计费系统的开发就只有一人，还是刚毕业的同学。目前看来，也是难为这位同学了。</p><p>技术债务的问题不是小事，千里之堤毁于蚁穴。既然我们找到了问题的症结所在，那么解决的方式也就显而易见了，一个字：拆！我们分析了所有的业务，订单是最大也是最复杂的一个业务，而结算和账单考虑到后期有可能迁移到云支付团队，我们决定优先把订单系统拆分出去！</p><h2 id="拆分的阵痛"><a href="#拆分的阵痛" class="headerlink" title="拆分的阵痛"></a>拆分的阵痛</h2><p>订单拆分说起来容易，做起来难。套用一句业界常说的话，就是开着飞机换轮胎。因为在我们拆分的同时，不断地有新的业务需求进来，还有一些bug需要处理，所以不太可能让我们专门进行拆分的工作。因此，为了不影响正常的业务迭代，我们决定拉出独立分支进行开发。我们分出两人专门处理拆分的工作。</p><p>为了最小化风险，订单拆分我们分了两步进行：一，模块独立；二：系统独立。</p><h3 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h3><p>模块独立是将订单的代码首先在工程内部独立出来，我们采用独立Module的形式，将订单独立成了一个Order的模块。它拥有完全独立的服务层、业务层以及持久化层。其他模块可以依赖Order，而Order不能依赖除公共模块外的其他业务模块。整体的模块划分如下图所示。模块的拆分过程中我们也发现了原先很多不合理的地方，例如：其他服务直接操作订单的持久化层(DAO)、模块直接依赖关系混乱、Service所在的Pacakge不合理、存在大量无用的代码和逻辑、随意的命名等。我们边拆分边重构，虽然进度比预期要缓慢一些，但整体上在向着合理的方向进行。</p><img src="/2017/12/15/蜂巢计费系统架构升级之路/module-indepent.png" title="模块拆分"><p>模块独立的过程中我们遇到了业务层级关系的问题。由于订单模块不再依赖于其他业务模块，而又有一些业务逻辑是由订单触发的，需要在计费模块完成，我们又不能直接调用计费模块的Service。针对这个问题，我们采用了<code>领域事件</code>的方式来解耦，简单来说就是订单通过发布事件的方式来与其他模块进行通信，当时实现的代码其实也相当简单，可以参考:<a href="https://gist.github.com/mymonkey110/aba58de452928bec2243848bb2c9b84a。" target="_blank" rel="noopener">https://gist.github.com/mymonkey110/aba58de452928bec2243848bb2c9b84a。</a></p><p>我们并没有独立拆分web层，因为系统还没有独立，web层作为统一的打包入口也承载着订单的流量。而且，Controller层的逻辑相对比较简单，完全可以在系统独立时再做。通过大家的努力，8月底订单已独立模块的方式上线了，一切正常。</p><h3 id="系统独立"><a href="#系统独立" class="headerlink" title="系统独立"></a>系统独立</h3><p>模块拆分完成后，仅接着就是系统独立，此时我们需要将订单系统独立部署。这里一个关键的问题是，独立部署意味着单独提供服务，而依赖订单系统的业务方非常之多，包含前端、主站、大部分的PaaS业务和计费，都有需要直接依赖订单接口的地方，冒然独立风险很大。针对这个问题，我们采用使用haproxy七层转发代理来将流量分发到不同的vip来解决。虽然，在上线过程中遇到了一些坎坷，但最终还是成功了。现在看来这个选择是非常对的，因为这样可以在业务方无感知的情况下平滑升级。但长远来看，最终我们还是以独立的vip对外保留服务。</p><img src="/2017/12/15/蜂巢计费系统架构升级之路/deploy-indepent.png" title="独立部署"><p>订单和计费直接我们采用RabbitMQ来完成主体通信，关于采用MQ还是HTTP调用我们内部还进行了一番争论。之所以最终还是采用MQ来进行通信，是因为我们发现很多业务流程并不需要计费系统立即响应（大部分流程都是订单触发的），也就是我们常说的弱依赖。另外，职责上计费系统的响应的质量也不应影响到订单的主体流程，举个例子：用户支付了一个云主机的订单，如果计费系统此时无法响应，业务上相对来说可以接受过一小会儿计费再处理，而不是把订单直接退款给用户。MQ的引入在技术和职责层面都将订单和计费分的更开了。当然，强依赖的服务是我们无法避免的，其中之一就是结算模块还留在计费中，订单需要通过接口调用结算服务来完成支付。</p><p>前期，我们在模块独立时采用事件解耦的方式，在此时也获得了收获。我们通过一个统一的转化层，将那些事件直接转化层RabbitMQ可以识别的消息，这样代码的改造工作就大大减少了。</p><p>系统独立后一个直接的表象就是每个系统的代码行数大大降低了。独立前，整体的代码行数已经达到了12W行以上（包含配置文件），独立后，计费系统降低到了10W以下，订单维持在4W以下。代码行数的降低将直接提高系统的可维护性。个人认为如果一个工程里的代码超过10W行，那么维护性将大大降低，除非是那些有着严格自律意识的团队，否则，我建议还是尽量降低代码行数。</p><p>经过大家一个月的努力，订单系统终于已独立的姿态提供服务了。过程很艰辛，但是收获良多。</p><h3 id="拆分的收获"><a href="#拆分的收获" class="headerlink" title="拆分的收获"></a>拆分的收获</h3><p>订单独立后，一个直接的好处就是我们能独立的思考问题了，这在以前是很难做到的一件事情，因为大家不得不小心翼翼的处理那些依赖，做事会畏手畏脚的。另外一个好处就是，我们的工作可以有侧重点的进行了。订单业务可以说是产品最为关注的业务，也是计费对外暴露的主要入口。<br>下图就是我们在拆分后规划订单的业务架构，大家对后期的订单规划充满期待。</p><h2 id="多Region的挑战"><a href="#多Region的挑战" class="headerlink" title="多Region的挑战"></a>多Region的挑战</h2><p>公有云产商面临的一大挑战就是多Region环境的支持。普通的互联网行业出于高可用的考虑，往往会把核心系统部署到多个机房，然后根据自己的实际应用场景选择冷备、双活甚至三活。我们经常听到的“两地三中心”、“三地五中心”等等高大上的名词就是代多机房高可用的缩影。这些行业做多机房部署的主要目的是为了提高系统的可用性，不是其业务的必须属性。换句话说，他们不做多机房部署也可以，做了当然更好。而公有云产商不一样，多Region部署就是其行业属性之一。如果哪个云产商不提供多region产品的支持，那么它肯定是不完整的。不得不承认，我们在这方面的经验是比较欠缺的，在多Region的支持上走了一些弯路。</p><h3 id="摸着石头过河"><a href="#摸着石头过河" class="headerlink" title="摸着石头过河"></a>摸着石头过河</h3><p>今年上半年的时候，蜂巢开始计划启动北京Region，预计年中交付，当时对我们横向业务提出了很大地技术挑战。一是在于横向系统设计之初并没有考虑到对Region环境的支持，我们很被动；二是我们并没有跨Region系统设计的经验，我们很着急。计费系统面临的问题更加严重，因为它对数据的一致性要求更高，而且出错地影响范围也更大。而且当时计费的技术债务已经很高了，产品的需求列表也拍了很长，套用一句很形象的话说，“留给我们的时间不多了”。</p><p>在这种情况下，我们“胆战心惊”的给出了第一版的多Region设计方案，主体架构如下所示：</p><img src="/2017/12/15/蜂巢计费系统架构升级之路/double-region.png" title="双region架构"><p>因为当时计费系统还没有拆分，所有的业务都在一个系统中完成的，就是我们常说的“大泥球”系统。这种情况下我们很难做到多Region部署，订单和账单其实只有在一个Region部署就可以了，而计费的数据采集和请求分发是要下沉到各个Region的，而计算过程可以集中完成。采用”双主”同步复制的方案实则是无奈之举。数据库的同步只能基于实例级别，而无法细分到表，我们各Region中计费数据库中存在资源的计量表，这个数据需要同步到杭州Region来完成。为了避免“脑裂”的问题，我们特别将该表的主键采用UUID的形式。存量表因为无法做大规模修改，我们通过限制北京MySQL用户的权限来避免写入和修改全局表。</p><p>这个设计很糟糕，但是当时的条件限制，我们也拿不出更好的设计了。虽然上线的过程有些曲折，当这个架构还是成功运行了，这是令我们最为欣慰的事情。因为为了适配这个架构，团队的小伙伴做了很多工作。不可否认，这个架构存在诸多弊端，其中最大的隐患就在于数据库的“双主”同步，这就像一颗随时会爆的炸弹萦绕在我们心头。当时专线还没有搭建好，所有的流量均通过外网隧道代理，糟糕的网络质量无疑放大了这个风险。为此，DBA们向我们吐槽了好久，幸好我们抗打击能力很强。</p><h3 id="涅槃重生"><a href="#涅槃重生" class="headerlink" title="涅槃重生"></a>涅槃重生</h3><p>在做完双Region的支持以后，计费团队就继续做产品需求了，因为架构调整导致需求列表已经很长了。而且当时也说的是，短期内（至少今年）不会再有第三个Region了，我们也想着快点做完，多花点精力投入到重构中。但是计划赶不上变化，9月底我们被通知到第三个Region来了，而且已经被提高到第一优先级支持了。</p><p>有了第一版双Region的经验，这一次我们淡定了很多。当然，我们不可能在沿用第一版的设计了，因为DBA就会跟我们拼命的。回过头来梳理多Region支持面临的问题时，我发现一开始我们就自己给自己挖了一个坑，然后往里面跳。横向支撑系统显然都需要对所有Region提供支持，但这并不代表其需要在各个Region内部署(我还与团队其他的小伙伴分享了这方面的想法，网上应该还能找到这一次分享的ppt——《跨Region实践初探》)。因为公有云产商经常会提供多个Region的服务，有得甚至达到几十个Region，如果横向支持系统每个Region都要全量部署的话，那么我们花在运维上的精力就可以拖垮我们，更不要说还有最为困难的数据的一致性问题。</p><p>其实多Region的支持的问题我们总结出主要表现在一下两个方面，一是应用层面的接口互通；二是底层数据库的同步。</p><img src="/2017/12/15/蜂巢计费系统架构升级之路/region-core-problem.png" title="2个核心问题"><p>我们先说底层数据库的同步，对计费系统而言，数据的一致性是至关重要的，但多机房部署是在挑战CAP定律。是不是就没有了这样的数据库方案了呢，有，那就是Google的Spanner，号称可以在全球做到强一致的数据库。但是我们没有这样的数据库。其实我们也考虑使用NoSQL数据库——Cassandra，但是这个数据库运维起来太复杂，我们也没有这方面的经验，也就放弃了。还是回归到MySQL，受限于传统关系型数据库在扩展性方面的问题，我们不可能把整个库在各个Region都同步一份。但是计费原始数据又必须在各个Region内收集，于是我们决定——拆，把计费拆层两个部分，分为bill-agent(数据采集)和bill-central(数据计算)两个部分。</p><img src="/2017/12/15/蜂巢计费系统架构升级之路/region-new-arch.png" title="新计费多region架构"><ul><li>Bill-Agent负责Region内日志的收集和简单聚合。</li><li>Bill-Central负责日志收集外的全局事务处理。</li></ul><p>通过这样的拆分，架构就清晰多了。再多加Region，我们只需要部署Bill-Agent就可以了。Bill-Agent将处理过的计费数据写入本地库的一张资源表，利用NDC（马进在网上分享过关于这个中间件的介绍）将资源表单向同步到Bill-Central的中央库，然后Bill-Central统一在对计费数据进行处理。有意思的是，这张资源表就是我们在第一版设计中新建的资源表，因为我们将主键修改为UUID，所有使用NDC同步表的方案是相当顺利的。当然，NDC在我们其他项目的跨Region支持上也发挥了重要作用，比如：跨机房缓存更新的问题。这一版的数据库方案在技术评审时大家都比较满意，DBA也肯定了我们的方案。</p><p>现在再来看跨Region调用的问题。在多Region的横向系统中，我们发现或多或少的存在着机房间的接口调用问题。这些问题有可能是某些Region的库不能写需要路由到主库来写导致的，也有可能是全局缓存的问题，还有就是Global业务向Region内服务发送指令。计费属于最后一种场景，我们有一些业务场景需要由杭州Region触发，然后调用各个Region内的服务的接口。在第一版的实现中，计费系统自己实现了跨Region代理部分，但是实现的不是很好，代码的可维护性比较差，加重了调试的难度。这一版的设计中，我们决定把跨Region接口代理单独拿出来重新做，结合多Region的应用场景，然后封装一些非功能性的特性，这就成了后面我们很重要的一个组件——RegionProxy。</p><p>RegionProxy最开始是为了解决跨Region调用的非功能性问题，简化应用系统处理的成本。但是设计上经历了比较大的调整。最开始的设计我们是希望Region内所有跨Region的HTTP调用都能通过RegionProxy来代理，RegionProxy之间能够发现对方并且相互通信，那么Region内的应用系统就只需要与本Region的RegionProxy通信就可以调到任意一个Region的应用系统了。但是在方案评审的过程中，我们发现如果都用RegionProxy代理，可能会导致跨Region调用多出一跳或者两跳，调试可能会比较困难。后来，我们放弃了这个方案。再后来，我们发现ServiceMesh的方案和我们最初RegionProxy的方案是十分相似的。</p><p>在RegionProxy的设计上我们进行了简化处理，我们将所有Region的业务系统录入到一个全局的配置中心(我们自己开发的ConfigCenter)中，然后通过一个自己开发的一个HttpProxy的Java库来与ConfigCenter通信来完成跨Region的调用。这样做的好处就是使用方用起来比较轻量，但是在网络连通性方面我们需要与所有Region的系统做到互通。在开发Proxy库的时候，我们不仅对跨Region的HTTP调用进行了封装，而且对普通的HTTP调用也加入了非功能性的封装，这样系统可以通过Proxy库完成所有的HTTP调用请求，极大的简化了代码的维护成本。后面，我们使用RegionProxy来代理请求后，确实删除了很多以前的无用代码，整体流程上也清晰了许多。</p><h3 id="多Region的感悟"><a href="#多Region的感悟" class="headerlink" title="多Region的感悟"></a>多Region的感悟</h3><p>经过两版多Region的改造，我们确实收货了很多宝贵的经验，非常难得。实际上，在多Region的支持上，大家需要清晰地认识到为什么要支持多Region，以何种方式去支持多Region，多Region支持与高可用的关系等基本问题。如果这些问题回到不好，或者不清楚，那么很容易就会掉到陷阱中去。另外一个感悟就是结合业务的实际场景，第二版的多Region架构我们之所以能够这么设计，就在于计费系统不需要实时出账，我们完全可以把数据保存下来，离线计算以后再出账，这是可以接受的。但这并不适用与所用情况，有些性能要求很高的横向业务就不适合这种场景。</p><h2 id="拿来主义"><a href="#拿来主义" class="headerlink" title="拿来主义"></a>拿来主义</h2><p>前面提过几次技术债务的问题，有些问题是可以通过工具来解决了，有些只能通过内部重构来解决。左耳朵耗子曾经说过一句话对我感触很大，大意是说有些公司在解决问题时偏流程，有些公司偏技术。我想我们既然是技术团队，在解决问题时能通过技术方式解决的就应该尽量用技术解决，流程和人都是不可靠的。</p><h3 id="难以管理的配置文件"><a href="#难以管理的配置文件" class="headerlink" title="难以管理的配置文件"></a>难以管理的配置文件</h3><p>计费项目面临的诸多问题之一就有配置文件的管理，因为业务流程的原因，计费系统有着大量的各种各样的配置。以前我们把配置文件放到工程里面，通过自动化部署平台来指定使用不同的配置文件。这样做的一个显著问题就是代码和配置耦合起来了，每次修改什么配置都得提交代码，而我们提交又有着一套严格地流程，导致整体效率不高。另外一个问题就是可视化的问题。往往QA在线下环境测试都是通过的，而上线以后出了问题，基本上都是配置导致的问题。针对这几个的问题，我们决定使用<a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">Apollo</a>来管理我们的配置，通过整合Apollo，我们的两个项目（订单和计费）都做到了工程零配置，所有的配置都放到Apollo上进行管理，好处良多。</p><img src="/2017/12/15/蜂巢计费系统架构升级之路/apollo.png" title="apollo配置管理"><h3 id="替换定时任务框架"><a href="#替换定时任务框架" class="headerlink" title="替换定时任务框架"></a>替换定时任务框架</h3><p>计费系统严重依赖于定时任务，有许多流程需要通过定时任务来推动。以前我们使用QUARTZ+MYSQL来作为我们分布式定时任务框架，但是这种做法的可维护性太差，而且对数据库侵入很高，对测试也不友好。在QA的不断吐槽中，我们决定替换掉现有的定时任务框架。在调研开源的定时任务框架后我们决定使用<a href="https://github.com/elasticjob/elastic-job" target="_blank" rel="noopener">Elastic-Job</a>来作为我们的分布式定时任务框架。目前，我们的两个项目的所有定时任务（除bill-agent外)都已迁移到Elastic-Job上来了。</p><img src="/2017/12/15/蜂巢计费系统架构升级之路/elastic-job.png" title="Elastic-Job定时任务"><h2 id="抽象化设计"><a href="#抽象化设计" class="headerlink" title="抽象化设计"></a>抽象化设计</h2><p>如果你要问我做蜂巢计费最困难的地方是什么？我的回答肯定是业务太复杂了。这种复杂性不是因为我们架构设计的不好导致的复杂，而是业务本身就是十分复杂的。现在计费系统需要支持十几种产品的售卖形式，涵盖IaaS、PaaS和SaaS的绝大部分产品，同时各个产品的售卖和计费模式都存在或多或少的差异，这让我们很难通过一个统一的模型就涵盖所有的场景。我们找到了一条缓解这个问题的方式——抽象化。</p><p>横向系统或者支持系统如果需要服务多个产品，那么抽象化设计是不可或缺的一个缓解。如果越早进行抽象化，那么后期对接和维护的成本也就会越低，还能把系统的边界划分得更清晰。计费系统早期的设计在抽象化方面没有过多的规划，在后期的对接方面又处于比较弱势的一方，导致计费系统出现了大量的特化代码。这些特化代码对一个服务十几个产品的支持系统无疑是伤害巨大的。现在我们已经意识到了问题的严重性，也着手在做这方面的重构工作了。但是挑战依然很大，因为业务的复杂性是无法通过技术手段就能降低的，这方面我们只有和产品、运营和销售各方面一起努力，打造一个合理、灵活、稳定的新计费。</p><p>抽象化设计因为我们还在进行中，后期有机会再分享。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从八月底加入计费团队以来，收获良多，无论是在技术上，还是在对业务的理解上，都有了许多新的认识。最为给力的还是团队的小伙伴们，因为计费本身的需求非常多，处理这些需求人都只刚刚够。后来我们又做了两版跨Region改造、订单拆分、框架替换、抽象化等优化工作，迭代周期从两周一次压缩到了一周一次，开发和QA的小伙伴也都是任劳任怨。当然，大家能在这个过程中有所收获才是最关键的。</p><p>计费系统可以说是我接触过的最为复杂的一个系统，越是复杂的系统越需要清晰的头脑和良好的设计。云计算产商的博弈已经到了白热化阶段了，大家拼的不光光是每个产品的质量和体验，还有整个云平台的内功。公有云平台本身就是一个庞大、复杂的系统，如何把这个系统建设好，用户体验做好、服务质量提高、稳定性得到保障，这本身就是极为有难度的一件事情。计费系统作为公有云平台一个重要的组成部分，可以说扮演着一个极为关键的角色。做得好可以对整个平台提供助力，而做的差则会拖慢整体的发展进程。我们已经找到了适合自己的一条道路，相信会走上正轨！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背景&lt;/h2&gt;&lt;p&gt;蜂巢计费系统为网易云基础服务（网易蜂巢）提供整体的计费服务，业务范围涵盖完整的产品售卖流程，包含定价、订单、支付、计费、结算、优惠、账单等主体功能，支持十几种不同产品的售卖，产品形态上贯穿了IaaS、PaaS和SaaS类别。同时，计费方式还提供了了按量、包年包月、资源包等多种方式。该项目的业务范围之广，玩法种类之多，数据要求之严注定了它将成为一个烫手的山芋，而且还是一个吃力不讨好的工作。&lt;/p&gt;
&lt;p&gt;该项目在人员上已经几经易手，就我所知，已经换过两拨完整的开发和测试团队了，而且已经全部离职。不得不说，该项目已经变得令人谈之色变，让人敬而远之。在这样的背景下，后期接手的开发和QA不得不硬着头皮上，踩着雷过河，小心翼翼的应对着不断涌来的业务需求。随之而来的是高居不下的bug率，越来越难以维护的代码，无法扩展的架构问题，我们开始意识到这样下去是不行的。于是我们从8月份开始了漫漫的架构升级之路。&lt;/p&gt;
    
    </summary>
    
      <category term="云计算" scheme="http://michael-j.net/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="cloud" scheme="http://michael-j.net/tags/cloud/"/>
    
      <category term="云计算" scheme="http://michael-j.net/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="计费" scheme="http://michael-j.net/tags/%E8%AE%A1%E8%B4%B9/"/>
    
      <category term="微服务" scheme="http://michael-j.net/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>编程心智(二)——二八定律对软件开发的影响</title>
    <link href="http://michael-j.net/2017/11/03/%E7%BC%96%E7%A8%8B%E5%BF%83%E6%99%BA-%E4%BA%8C-%E2%80%94%E2%80%94%E4%BA%8C%E5%85%AB%E5%AE%9A%E5%BE%8B%E5%AF%B9%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>http://michael-j.net/2017/11/03/编程心智-二-——二八定律对软件开发的影响/</id>
    <published>2017-11-03T12:49:13.000Z</published>
    <updated>2017-11-05T04:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多人都听说过二八定律，这是一个适用性非常广泛的定律。我发现二八定律同样适用于软件开发，并对其产生了十分深远的影响。这次我想聊聊二八定律是如何影响我们日常的开发工作的，希望通过这个话题来改变一下大家习以为常的开发思维。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二八定律是19世纪末20世纪初意大利经济学家巴莱多发现的。他认为：</p><blockquote><p>在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此又称二八定律。</p></blockquote><p>二八定律有相当广泛的普适性，不论是在生活中，还是在工作上，只要你细心观察，都会发现其身影。</p><h2 id="功能需求对软件开发的影响"><a href="#功能需求对软件开发的影响" class="headerlink" title="功能需求对软件开发的影响"></a>功能需求对软件开发的影响</h2><p>不知道大家有没有发现这样一个事实，随着我们系统要处理的业务功能越来越多，我们添加一个新功能的代价也越来越大。很有意思，我发现业务功能与添加一个新功能要做出的努力呈现出类似于下图所示的关系。</p><img src="/2017/11/03/编程心智-二-——二八定律对软件开发的影响/effort-feature.png" title="effort-feature"><p>起初，为了使得一个新系统能运行，我们不得不处理一些非业务性的工作，比如搭建框架、技术选型、架构设计、部署结构设计、资源申请等等。而一旦这些基础性的工作完成，那我们就可以快速的完成业务需求。大概花费我们20%的精力就可以满足80%的业务功能，这些业务功能也是系统的主要功能。但是再往后新增功能，所要做出的努力就会成指数增长。这张图与<a href="https://www.amazon.cn/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E7%A6%8F%E5%8B%92/dp/B003LBSRDM/ref=sr_1_1?qid=1509850680" target="_blank" rel="noopener">P o EAA</a>中的领域逻辑复杂度与工作量之间的关系类似。当然，这个曲线并不是绝对的，影响这条曲线的关键在于系统的代码架构，好的代码架构能让你在处理复杂的业务需求时更加从容。（题外话，我认为一个优秀的程序员应该具备处理复杂需求的能力。）</p><p>既然我们发现了这个规律，是否能指导我们的日常开发工作呢？答案是肯定的。因为80%的功能基本已经满足了大部分人的需求，而为了满足少数人的需求而增加80%的努力是不值得。当然，公司完全有理由要求你这么做，与此同时你也可以把这个利害关系介绍给他们听。</p><p>甚至在细分到x轴和y轴，我们可以继续运用二八定律来分解。80%的业务功能其实大概只有20%是核心功能，其余的只是为了优化体验或者简化流程为存在的；而对于20%的努力而言，其中80%的工作主要集中在满足核心的业务需求而存在的，我们应该也必须投入这么多精力来设计并开发这些功能，因为它们是整个系统的核心。</p><h2 id="性能优化对软件开发的影响"><a href="#性能优化对软件开发的影响" class="headerlink" title="性能优化对软件开发的影响"></a>性能优化对软件开发的影响</h2><p>程序员总是对性能优化这个话题充满激情，好像这成了唯一彰显其技术能力的手段。确实，要把应用系统的性能优化到极致，确实要付出大量的努力。但实际上性能优化所付出的努力与取得的效果也符合二八定律。其工作量与索取的效果类似于下图所示。</p><img src="/2017/11/03/编程心智-二-——二八定律对软件开发的影响/effort-performance.png" title="effort-performance"><p>不消多说，凡是做个性能优化的同学应该都会有这样的感触：只用加个索引或者加上缓存就可以使得系统的性能大幅度提供。使用常规的优化手段（大概耗费20%的精力）就可以取得显著的效果（提升80%的性能）。但是要取得另外20%的性能提升要付出努力将大大增加。掌握这个规律相信大家应该知道如何“使力”了。</p><h2 id="项目人数对开发效率的影响"><a href="#项目人数对开发效率的影响" class="headerlink" title="项目人数对开发效率的影响"></a>项目人数对开发效率的影响</h2><p>还一个比较显著的符合二八定律的场景就是在项目管理上。</p><img src="/2017/11/03/编程心智-二-——二八定律对软件开发的影响/people-progress.png" title="people-progress"><p>同时参与一个项目的人并非越多越好，实际上影响应项目进度只取决于少数人（20%），后面增加更多的人其实收效甚微。我个人也是倾向于不要在一个项目上投入过多的人力，要精不要多。现在微服务这么流行，我觉得也有类似地影响。它在架构层面把一个大系统拆分成一个一个小服务，让每个服务有少数几个人负责，这样整体的开发效率会更高。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>类似上面的例子还有很多，比如迭代周期对软件质量的影响、服务数量对整体可用性的影响等等，只要你细心观察就会发现二八定律在我们的日常开发工作中无处不在。更为重要的是，我们不仅要发现其存在，更要在那20%的重点上下功夫，避免在80%的事情上瞎费劲。</p><p>（文中配图是我用Windows的画图程序生成的，不好看望大家见谅。）</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%85%AB%E5%AE%9A%E5%BE%8B/747076?fr=aladdin" target="_blank" rel="noopener">二八定律</a><br><a href="https://www.amazon.cn/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E7%A6%8F%E5%8B%92/dp/B003LBSRDM/ref=sr_1_1?qid=1509850680" target="_blank" rel="noopener">企业架构模式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多人都听说过二八定律，这是一个适用性非常广泛的定律。我发现二八定律同样适用于软件开发，并对其产生了十分深远的影响。这次我想聊聊二八定律是如何影响我们日常的开发工作的，希望通过这个话题来改变一下大家习以为常的开发思维。&lt;/p&gt;
    
    </summary>
    
      <category term="编程心智" scheme="http://michael-j.net/categories/%E7%BC%96%E7%A8%8B%E5%BF%83%E6%99%BA/"/>
    
    
      <category term="编程心得" scheme="http://michael-j.net/tags/%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"/>
    
      <category term="二八定律" scheme="http://michael-j.net/tags/%E4%BA%8C%E5%85%AB%E5%AE%9A%E5%BE%8B/"/>
    
      <category term="软件开发" scheme="http://michael-j.net/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>编程心智(一)——代码架构与系统架构</title>
    <link href="http://michael-j.net/2017/09/24/%E7%BC%96%E7%A8%8B%E5%BF%83%E6%99%BA-%E4%B8%80-%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>http://michael-j.net/2017/09/24/编程心智-一-——代码架构与系统架构/</id>
    <published>2017-09-24T12:00:27.000Z</published>
    <updated>2017-09-25T08:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开头的话"><a href="#写在开头的话" class="headerlink" title="写在开头的话"></a>写在开头的话</h2><p>想写这个系列文章很久了，但是对于一个重度的拖延症患者来说，决定写一个系列文章还是颇有挑战。最开始，只想写一两片文章分享一下自己对于编程的感悟。但随着时间越拖越久，发现想写的东西越来越多。直到今天，居然发现我的博客的To-Do-List（目前我在使用<code>WunderList</code>，很好用的一个To-Do-List工具)文章数达到了10篇，终于说服自己动笔了。<br>“编程心智”这个词这段时间一直萦绕在我的脑海中，我觉得这个词最能表达我想分享了内容了。我希望通过这个系列文章分享自己对于代码、编程、架构以及软件工程的理解与感悟，另外，还有隐藏在代码后面的程序员心智。所有文章仅代表个人观点，没有是非对错的标准。如果你对文章中的观点不认同，还请给我留言，不同的声音对于进步有着极大的促进。</p><a id="more"></a><p>选择“代码架构与系统架构”作为第一篇文章是因为我发现很多人对“架构”的误解很深，而且国内关于“代码架构”的分享和书籍凤毛麟角，似乎只有流弊的“系统架构”才能成为谈资。我不太能理解这个现象，好像大部分人都完全不用操心“如何写好代码”这回事，似乎只要有一个看上去比较“完美”的系统架构就能解决所有的事情。但根据我的实际经验，现实情况往往不是这样，有时候甚至相反。有些项目的系统架构图画的非常“漂亮”，引入了很多新潮的技术，每个组件都划分的很清楚，系统之间如何通信，模块之间如何引用等等都一目了然。但是当你去看项目的真实代码时，完全是另外一番景象。至于为什么会这样，我想很大一部分原因是“系统架构图”已经沦为了一种满足KPI考核手段，而通常你的老板不会深入地去理解你的代码，更不要说指出其中的问题了。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>相信很多人对系统架构都不陌生，只要是从事软件开发领域的人，或多或少都接触过系统架构。系统架构最直观的表现就是系统架构图，下图就是一张系统架构图，摘自李智慧老师<a href="https://www.amazon.cn/dp/B00F3Z26G8/ref=cngwdyfloorv2_recs_0?pf_rd_p=7149a3bb-2ee6-4f99-92eb-d87852365f8c&amp;pf_rd_s=desktop-2&amp;pf_rd_t=36701&amp;pf_rd_i=desktop&amp;pf_rd_m=A1AJ19PSB66TGU&amp;pf_rd_r=R2PPN3T6JNKNPP0HTHWS&amp;pf_rd_r=R2PPN3T6JNKNPP0HTHWS&amp;pf_rd_p=7149a3bb-2ee6-4f99-92eb-d87852365f8c" target="_blank" rel="noopener">大型网站技术架构:核心原理与案例分析</a>。</p><img src="/2017/09/24/编程心智-一-——代码架构与系统架构/部署架构图.png" title="部署架构图"><p>系统架构是一个比较大的概念，从技术角度来看，它往往以部署架构图的形式出现（上图就是）；而换到业务视图，它又以另外一种形式出现，如下图。</p><img src="/2017/09/24/编程心智-一-——代码架构与系统架构/业务架构图.png" title="业务架构图"><p>不论是部署架构图还是业务架构图，它们都反映了系统与系统之间的一种关联关系，从更加宏观的角度反映系统在全局中的作用和定位。如果你是某个系统的开发者或者负责人，那么你的系统会在系统架构图中以一个方框出现。通过系统架构图，你的老板和同事能很直观地了解到你的系统在全局中的位置以及你服务的层次。这样做有好处的，它降低了技术人员之间以及技术和业务人员之间地沟通成本。</p><p>实际上，关于系统采用什么样的中间件、何种数据库和缓存、选用哪种服务框架等等，甚至今年非常火的微服务架构，这些统统都属于系统架构的范畴。关于系统架构方面的书籍和文章已经非常多了，而且国内的分享也主要集中于此，我就不再这方面展开了。</p><h2 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h2><p>相比于系统架构，代码架构对很多人可能就陌生许多。我刚刚去Google一下，发现甚至没有关于“代码架构”的权威定义。那么什么是代码架构呢？打个比方，如果你的系统在系统架构图中只是一个方框，那么代码架构就是介绍这个方框是如何组成和实现的。代码架构的关注点在一个工程（Project）内部，它描述了你的整个工程代码是如何组织和实现的。简而言之，系统架构是宏观层面的体现，而代码架构是微观层面的体现。</p><p>在我的博客中有很多关于DDD的文章，而DDD本身就是一种代码架构。除此之外，还有MVC、CQRS、Event Souring等等。那么，设计模式是否也可以成为代码架构呢？在某种程度上是的，因为它可以指导你如何组织代码的实现，如何在代码层面解耦，但是，光光通过设计模式你无法组织起你的整个工程代码，所以从严格意义上讲，设计模式并不是一种代码架构。代码架构也可以通过图文的形式表现，不过这完全取决于你采用何种代码架构。下图是我目前负责的一个系统的代码架构，这个系统的核心在于策略语言（Policy）。</p><img src="/2017/09/24/编程心智-一-——代码架构与系统架构/六边形架构.png" title="六边形架构"><p>熟悉DDD的人一眼就可以看出来这是DDD种的经典六边形架构（题外话，至今我不太明白为什么是六边形）。如果你的工程采用MVC或者CQRS架构进行组织，可能会画出完全不一样的架构图。我很庆幸，在我正式的职业编程生涯的早期接触到了DDD这种编程思想，它对我的编程生涯影响很大，让我少走了很多弯路。如果你还没有接触过DDD，我希望你能立马买一本<code>Eric Evans</code>的<a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B01GZ6T12K/ref=sr_1_1?ie=UTF8&amp;qid=1506266953&amp;sr=8-1&amp;keywords=%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">领域驱动设计:软件核心复杂性应对之道</a>，细细研读此书，字里行间都体现着作者对软件开发的深刻理解。</p><p>为什么我说代码架构是如此的重要？是因为其奠定了大型系统的基石。我认为衡量一个优秀的程序员的能力之一就包含其对复杂问题的解决能力。现实的问题往往比理论复杂很多，很多时候需要妥协、折中、权衡和取舍，如何在这些取舍之中不影响到软件的核心，这需要大量的经验。当然，这是有规律可循的，那就是代码架构。</p><p>好的代码架构会帮助你理解你的业务，哪些部分是你系统的核心，哪些部分只是技术层面的实现。换句话说，好的代码架构不光能知道你如何去组织你的代码，还能加深你对系统的理解。反过来，随着你对系统理解的不断深入，你又能更好的调整你的代码以适应新的变化。是不是所有的项目都需要代码架构呢？这取决于你的问题域。如果你的项目仅仅是一个<code>Hello World</code>程序，又或者是一个数据采集脚步，那么使用代码架构来组织代码可能没什么作用，反而使得你的代码变得更加复杂和臃肿。那么什么情况下你需要使用代码架构呢？我认为只要满足以下两个条件就行。</p><ul><li><p>你有一个相对固定的业务场景。固定意味着你要处理的问题域是有边界的，比如订单系统、库存系统、用户中心等等，它们所要处理的问题是比较集中和固定的。</p></li><li><p>你要解决的问题相对比较复杂。这看上去本身就比较矛盾，因为“复杂”本身就是相对的。这里的复杂的意义在于，你要处理的问题领域本身就具有复杂性。也许起初问题本身并不复杂，但随着时间的推移，系统要处理的问题也越来越复杂了，这要求你对问题有一定的前瞻性。</p></li></ul><p>事实上，上面两个条件是很容易满足，之所以还列出来因为在实际的开发过程中，我确实遇到过在以上两点犯错的情况。这主要出现在刚刚开始正式编程生涯的毕业生，他们对业务和要做的事理解程度不够，如果有经验丰富的程序员带的话，可以避免走一些弯路。正是因为上诉条件门槛较低，所以代码架构的应用场景非常广泛。有可能你现在的项目就在使用MVC架构，只是你没有意思到。我建议程序员能有意识地去了解你的代码架构，深入的思考一下目前的代码组织方式是最为合理的吗？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说了这么多，希望自己把代码架构和系统架构的核心点说明白了。两者都非常地重要，但是应用的场景各不相同，两者结合使用才能让你做出一个高质量的系统。相比于系统架构，代码架构往往被人们所遗留，但这并不代表其不重要。依我之见，代码架构的应用场景更为广泛，因为大部分的公司和项目其实并不需要一个复杂和“高大上”的系统架构，而与我们日常交互最多的就是一行一行的代码。深入的了解你的项目代码是如何组织对程序员来说是十分重要的，好的代码架构能起到事半功倍的效果。最后，个人建议将代码架构纳入到KPI的评判之中，最为直观的表现就是“技术债务”。好的代码架构会把项目的技术债务维持在一个比较低的水平；相反，糟糕的代码结构会让项目的“技术债务”越滚越大，最终到了不可收拾的程度。不过，技术债务如何量化，以及是否需要量化，目前这方面有着很多不同的身影，但是，能意识到这个问题的存在，至少，我们在向高水平的软件开发者迈出了一大步。</p><h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>编程心智这个系列我会持续地更新，但更新时间就不确定了。前面也说了，我是一个重度的拖延症患者，而且，最近项目的事情很多，一个接着一个。我会努力做到一个月一篇的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在开头的话&quot;&gt;&lt;a href=&quot;#写在开头的话&quot; class=&quot;headerlink&quot; title=&quot;写在开头的话&quot;&gt;&lt;/a&gt;写在开头的话&lt;/h2&gt;&lt;p&gt;想写这个系列文章很久了，但是对于一个重度的拖延症患者来说，决定写一个系列文章还是颇有挑战。最开始，只想写一两片文章分享一下自己对于编程的感悟。但随着时间越拖越久，发现想写的东西越来越多。直到今天，居然发现我的博客的To-Do-List（目前我在使用&lt;code&gt;WunderList&lt;/code&gt;，很好用的一个To-Do-List工具)文章数达到了10篇，终于说服自己动笔了。&lt;br&gt;“编程心智”这个词这段时间一直萦绕在我的脑海中，我觉得这个词最能表达我想分享了内容了。我希望通过这个系列文章分享自己对于代码、编程、架构以及软件工程的理解与感悟，另外，还有隐藏在代码后面的程序员心智。所有文章仅代表个人观点，没有是非对错的标准。如果你对文章中的观点不认同，还请给我留言，不同的声音对于进步有着极大的促进。&lt;/p&gt;
    
    </summary>
    
      <category term="编程心智" scheme="http://michael-j.net/categories/%E7%BC%96%E7%A8%8B%E5%BF%83%E6%99%BA/"/>
    
    
      <category term="编程心得" scheme="http://michael-j.net/tags/%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"/>
    
      <category term="代码架构" scheme="http://michael-j.net/tags/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
      <category term="系统架构" scheme="http://michael-j.net/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>再谈领域事件</title>
    <link href="http://michael-j.net/2017/08/13/%E5%86%8D%E8%B0%88%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/"/>
    <id>http://michael-j.net/2017/08/13/再谈领域事件/</id>
    <published>2017-08-13T11:11:14.000Z</published>
    <updated>2017-08-13T11:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>我以前写过一篇关于领域事件的文章——<a href="http://michael-j.net/2016/01/19/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/">实现领域事件</a>，随着在项目中深入的使用DDD架构，我对领域事件有了新的认识。尤其是采用领域事件来解耦代码这种方式对项目的发展具有深远的影响。</p><a id="more"></a><p>我在<a href="http://michael-j.net/2016/01/19/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/">实现领域事件</a>中主要谈到了如何在技术层面去实现发布事件与订阅事件，比较了几种不同的方式以及它们背后的原理。但随着我在自己负责的项目中严格地实施DDD架构时，我发现如何去发布订阅领域事件的意义远没有决定去做这件事情本身重要。换句话说，与其纠结与是使用基于<code>Spring</code>的事件架构还是<code>Guava</code>提供的<code>EventBus</code>，是使用同步发布还是异步发布，还不如想想去做这件事情对你的项目会产生怎样的影响。</p><p>为什么要使用事件？我认为这是所有人应该考虑的首要问题。对我来说，使用事件的意义有两个方面，一是在于流程上的解耦，二是在于代码层面的解耦。在代码层面的解耦是显而易见的，我就不再赘述了。那么流程上的解耦是什么意思了？我们先看一下一个普通的业务流程执行的链路。</p><img src="/2017/08/13/再谈领域事件/couple.png" title="正常的业务流程"><p>目前我们绝大部分人的思维习惯是顺序式的，体现在代码上也就是<code>A</code>做完它做的事情然后<code>B</code>继续处理，当然这么做没有任何问题，这也是最为简单直观的一种编程方式。我们再来看一下通过<code>Event</code>来解耦的链路。</p><img src="/2017/08/13/再谈领域事件/decouple-with-event.png" title="通过事件来解耦"><p>通过引入事件，我们将过程A和过程B解耦了。第一种方式和第二种方式都有着其重要的存在意义，决定何时采用第二种方式的关键在于<a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener">BoundedContext</a>。正好最近我在负责处理一个遗留系统的拆分问题，恰好有一个好的例子来说明这个问题。</p><p>这个遗留系统是一个计费系统，因为各种各样的原因，整个项目在代码层面非常混乱，代码之间各种凌乱的引用和交叉，这种感觉就和下图一样。</p><img src="/2017/08/13/再谈领域事件/一团乱麻.jpg"><p>我认为造成这个问题的根源在于开发人员并没有及时地识别出这个项目中的几个关键领域以及及早的将其进行隔离。更为让人遗憾的是开发这个项目的人员都已离职，后来接手这个项目的开发人员被堆积地需求压得喘不过气来，也就更没有时间来处理以前的技术债务问题。</p><p>实际上，这个项目包含多个领域，最为核心的三个领域就是订单、账单和计费。在和老大以及开发沟通过后，我们意识到系统拆分已经刻不容缓。目前我们在做的事情就是在工程内部进行代码级别的拆分，其中最为棘手的问题就是订单系统和计费系统的耦合太深。</p><p>仔细分析各个业务流程之后我们发现，很多耦合都是可以避免的。大部分的业务流程都是由订单系统触发，然后计费系统做出相应的变更。最终，我们决定使用领域事件来讲订单系统和计费系统解耦开。（PS:原系统中并没有使用DDD的开发模式，但这并不影响我们使用领域事件。)</p><img src="/2017/08/13/再谈领域事件/order-bill.png" title="order-bill"><p>上图是我们现在的做法，通过<code>OrderEvent</code>和<code>BillEvent</code>来将两个系统解耦开，然后将<code>Event</code>放到一个公共的Module中来达到Module级别的解耦。令人惊喜的发现在于，这种解耦的方式与我们规划中订单系统与计费系统通过MQ来通信达成了一致。后面我们只需要标准化这些事件，就可以做到无缝迁移到MQ中。</p><p>通过上面这个例子，我再总结一下使用领域事件的来解耦业务流程的应用场景：</p><ol><li>如果一个业务流程需要贯穿几个不同的受限上下文中，那么可以通过以发布领域事件的方式来避免上游系统耦合下游系统。这种解耦方式收益最大，因为其有利于后期系统间的拆分。</li><li>如果在同一个受限上下文中，也可以通过发布领域事件的方式来达到领域间解耦。</li></ol><p>至于为什么说以何种方式来发布事件不在那么重要，因为当你在项目采用了领域事件技术来解耦代码，你已经获得这项技术的90%的好处，而具体怎么执行就显得不那么重要了。我在另外一个项目中（这个项目完全采用DDD的模式来开发）就采用了最为朴实的方式来实现，不再基于Spring或者Guava了。</p><p>附上我目前的使用方法：<a href="https://gist.github.com/mymonkey110/aba58de452928bec2243848bb2c9b84a" target="_blank" rel="noopener">https://gist.github.com/mymonkey110/aba58de452928bec2243848bb2c9b84a</a></p><p>如果你对使用领域事件的感触没有那么深，那么请记住这句话：代码间解耦用事件，系统间解耦用MQ！</p><p>参考资料：<br><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00IYTVWA6/ref=sr_1_1/462-1072474-8297663?qid=1502622410" target="_blank" rel="noopener">实现领域驱动设计</a><br><a href="https://www.amazon.cn/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E6%A0%B8%E5%BF%83%E5%A4%8D%E6%9D%82%E6%80%A7%E5%BA%94%E5%AF%B9%E4%B9%8B%E9%81%93-%E5%9F%83%E9%87%8C%E5%85%8B-%E5%9F%83%E6%96%87%E6%96%AF/dp/B01GZ6T12K/ref=tmm_pap_swatch_0?_encoding=UTF8&amp;qid=1502622410" target="_blank" rel="noopener">领域驱动设计:软件核心复杂性应对之道</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我以前写过一篇关于领域事件的文章——&lt;a href=&quot;http://michael-j.net/2016/01/19/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/&quot;&gt;实现领域事件&lt;/a&gt;，随着在项目中深入的使用DDD架构，我对领域事件有了新的认识。尤其是采用领域事件来解耦代码这种方式对项目的发展具有深远的影响。&lt;/p&gt;
    
    </summary>
    
      <category term="DDD" scheme="http://michael-j.net/categories/DDD/"/>
    
    
      <category term="领域事件" scheme="http://michael-j.net/tags/%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="event" scheme="http://michael-j.net/tags/event/"/>
    
      <category term="dddd" scheme="http://michael-j.net/tags/dddd/"/>
    
  </entry>
  
  <entry>
    <title>跨Region实践初探</title>
    <link href="http://michael-j.net/2017/08/02/%E8%B7%A8Region%E5%AE%9E%E8%B7%B5%E5%88%9D%E6%8E%A2/"/>
    <id>http://michael-j.net/2017/08/02/跨Region实践初探/</id>
    <published>2017-08-02T11:27:13.000Z</published>
    <updated>2017-08-02T11:39:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近网易云上线华北REGION(cn-north-1)地区的服务，在此过程中我们做出了很多调整以适应跨REGION架构。</p><a id="more"></a><p>在此分享一下我在团队内部的分享：<a href="http://pan.baidu.com/s/1eSgUYmY" target="_blank" rel="noopener">http://pan.baidu.com/s/1eSgUYmY</a> 密码：m72t</p><p>这次的跨REGION改造仅仅是第一步，我们意识到要支持多REGION，要做的事情很多。后续有机会进一步跟大家分享网易云在这方面的实践心得。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近网易云上线华北REGION(cn-north-1)地区的服务，在此过程中我们做出了很多调整以适应跨REGION架构。&lt;/p&gt;
    
    </summary>
    
      <category term="架构设计" scheme="http://michael-j.net/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="云计算" scheme="http://michael-j.net/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="架构" scheme="http://michael-j.net/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="高可用" scheme="http://michael-j.net/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="分布式" scheme="http://michael-j.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一次坑爹的Debug过程</title>
    <link href="http://michael-j.net/2017/06/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9D%91%E7%88%B9%E7%9A%84Debug%E8%BF%87%E7%A8%8B/"/>
    <id>http://michael-j.net/2017/06/21/记一次坑爹的Debug过程/</id>
    <published>2017-06-21T10:46:22.000Z</published>
    <updated>2017-06-21T10:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天QA跟我反馈说系统有几个接口反应很慢，起初我不以为意，因为这几个接口就是简单的写入和删除，最多就是再更新一下缓存，能有多慢。我让QA看看是不是网络抖动，延迟的问题，再看看我们的<code>access_log</code>里面响应时间是多少。QA说网络比较稳定，<code>access_log</code>里面显示要好几秒，这就让我有些诧异了。其中有一个删除用户XXX数据的接口响应特别慢，我们在测试环境去复现的时候果然复现了这个问题。当前端直接点击删除的时候，接口过了8秒多才返回，这肯定不正常了，而且<code>access_log</code>也印证了这一现象。</p><a id="more"></a><p><code>access_log</code>如下所示：（后面的代码和日志我都以XXX来代替这次的业务场景）。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.180</span><span class="number">.9</span><span class="number">.150</span> - <span class="number">2017</span><span class="number">-06</span><span class="number">-20</span><span class="string">_15:</span><span class="number">58</span>:<span class="number">55.960</span> DELETE <span class="regexp">/v1/</span>xxx<span class="regexp">/user/</span>comb/region<span class="number">-1497945389492</span>-vfxil <span class="number">200</span> <span class="number">95</span> (<span class="number">9586</span> ms)</span><br><span class="line"><span class="number">10.180</span><span class="number">.9</span><span class="number">.150</span> - <span class="number">2017</span><span class="number">-06</span><span class="number">-20</span><span class="string">_16:</span><span class="number">04</span>:<span class="number">00.239</span> DELETE <span class="regexp">/v1/</span>xxx<span class="regexp">/user/</span>comb/region<span class="number">-1497945389482</span>-yajym <span class="number">200</span> <span class="number">95</span> (<span class="number">4580</span> ms)</span><br></pre></td></tr></table></figure><p>铁证如山，<code>access_log</code>显示了确实是我们接口响应慢了。这让我有些纳闷了，这个接口的业务场景非常简单，就是删除用户的一条XXX记录，并清除跟它相关的表信息，最后发出一个领域事件，由一个listener来清除缓存，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">deleteUserXXX</span><span class="params">(<span class="keyword">long</span> uid, String code, String name)</span> <span class="keyword">throws</span> XXXNotFoundException </span>&#123;</span><br><span class="line">    Optional&lt;XXX&gt; result = getUserXXX(uid, code, name);</span><br><span class="line">    XXX xxx = result.orElseThrow(PolicyNotFoundException::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">long</span> xxxId = xxxx.getId();</span><br><span class="line"></span><br><span class="line">    xxxRepository.clearAllVersion(xxxId);</span><br><span class="line">    authorizeService.revokeXXXRefFromYYY(primaryAccountId, xxxId);</span><br><span class="line">    authorizeService.revokeXXXRefFromZZZ(primaryAccountId, xxxId);</span><br><span class="line">    xxxRepository.delete(xxxId);</span><br><span class="line"></span><br><span class="line">    DomainEventPublisher.publish(XXXEvent.newDeleteEvent(xxx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键是这个接口响应慢也不是每次都出现，响应慢的概率大概有50%，还是比较好复现的。还一个比较重要的信息就是，我们的SQL日志很快就打印完了，基本上我在<code>POSTMAN</code>一发出请求，我们的SQL也就执行完成了。但是<code>POSTMAN</code>此时并没有请求，那么就是说我们还没有返回<code>response</code>给前端。</p><p>怎么会这样？！不应该呀？难道是慢查询，索引的问题，我已经建了索引了呀，况且测试环境数据量这么小，不要索引也不至于这么慢啊！为了确定是不是慢查询的问题，我去咋们的APM工具(蜂巢的APM产品很强大，推荐大家使用)里面查询一下有没有捕获到慢查询的日志，结果很遗憾，并没有看到响应的慢查询日志。此时我就更困惑了。如果不是慢查询还能是什么。</p><p>走投无路的我只能祭出神器了——<code>JProfiler</code>，一款专业的APM工具。在折腾完一番环境配置部署等问题以后，我的客户端重要可以连上测试环境的jvm进行<code>profiling</code>了。用上了<code>JProfiler</code>感觉档次提高了好多，好像马上就能把问题解决了。下图是<code>JProfiler</code>的显示的调用过程。</p><img src="/2017/06/21/记一次坑爹的Debug过程/jprofiler.png" title="JProfiler"><p>调到这里，我只想说WTF！JProfiler显示这个HTTP调用只用了44ms就完成了。</p><p>我的内心又奔溃了，明明<code>access_log</code>显示花了8秒多，为啥<code>JProfiler</code>显示才44ms，难道<code>JProfiler</code>出错了？实际上，我更相信我自己的程序有问题，那为什么<code>JProfiler</code>显示我们的程序执行的很快呢？</p><p>看来<code>JProfiler</code>不能用了，我又想了很久。 <img src="/2017/06/21/记一次坑爹的Debug过程/我想到了.png"></p><p>难道是因为我agent加的太多了，因为测试环境为了统计需要jvm参数里面加了jacoco的agent；还有，apm的agent。这么多agent会不会导致某种性能问题了，虽然我自己都不太相信，但本着大胆尝试地原则我果断去掉了两个agent再重试了几次，现象依旧！</p> <img src="/2017/06/21/记一次坑爹的Debug过程/想不到吧.png"><p>幸好我内心强大，我还是很珍惜每次调试诡异BUG的机会的，因为能学到很多东西。此时的我已经没有什么手段了，事实摆着那里，接口响应很慢，也没有看到慢查询，<code>JProfiler</code>也没用了。然后我又祭出了我的第二个神器——<code>BTrace</code>。</p><p>相信很多人用过<code>BTrace</code>，这是在线调试的神器！虽然我不太想用这玩意，因为它要自己写脚本，内心有点排斥。但是我也没有别的办法了。准备再去看看<code>BTrace</code>的文档的时候发现<code>BTrace</code>的官方文档网站已经关了，WTF!</p> <img src="/2017/06/21/记一次坑爹的Debug过程/btrace.png"><p>我突然想到了以前看到过的另外一款神器——<code>Greys</code>。<code>Greys</code>也是一款在线调试神器，是阿里开源的一个工具。以前我没有用过这个工具，这次形式所迫，不得以而学之。看完文档之后发现它非常强大，不比<code>BTrace</code>弱，而且对开发者比较友好，至少不用去写脚本。我用<code>trace</code>跟踪了一下那个<code>deleteUserXXX</code>方法，结果如下：</p> <img src="/2017/06/21/记一次坑爹的Debug过程/greys.png"><p>啥？为啥我发一次请求这个方法会被调用两次？而且还是被同一个线程执行两次？为此我专门在代码入口处加了一条无用的log来看看这个方法到底被执行了几次。log显示这个方法只执行了一次。那为什么<code>trace</code>显示执行了两次，我为此纠结了很久，有知道的小伙伴可以告诉我。</p><p><code>Greys</code>没有提供太多有价值的线索给我，唯一有价值的信息就是那个线程名称。此时，我又灵关一闪，难道是<code>Stop The World</code> ？ 因为我用的同步请求的方式，所以一个request只会被一个thread处理，而又没有满日志打印，说明不是数据库的问题，只能是jvm本身的问题，难道请求的时候触发了GC ？ 又本着大胆尝试的精神我果断开启了<code>jstat</code>观察GC的情况。</p><img src="/2017/06/21/记一次坑爹的Debug过程/jstat.png"><p>观察很久以后发现自己还是太年轻。别说FGC了，连YGC都没几次，根本不是GC的问题。这可如何是好？对了，还有一个工具没试过，<code>jstack</code>，反正这么多工具都用了，也不差这一个了。</p><p>在请求过程中我用<code>jstack</code>来查看线程的运行状态，得到了如下的运行堆栈。堆栈显示<code>socket</code>在读取什么东西<br>，到底是什么东西呢？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http-nio-8080-exec-2"</span> <span class="number">#104</span> daemon prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000006b1b000 nid=<span class="number">0</span>x7392 runnable [<span class="number">0</span>x00007f74dece9000]</span><br><span class="line">   java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: RUNNABLE</span><br><span class="line">        at java<span class="selector-class">.net</span><span class="selector-class">.SocketInputStream</span><span class="selector-class">.socketRead0</span>(Native Method)</span><br><span class="line">        at java<span class="selector-class">.net</span><span class="selector-class">.SocketInputStream</span><span class="selector-class">.socketRead</span>(SocketInputStream<span class="selector-class">.java</span>:<span class="number">116</span>)</span><br><span class="line">        at java<span class="selector-class">.net</span><span class="selector-class">.SocketInputStream</span><span class="selector-class">.read</span>(SocketInputStream<span class="selector-class">.java</span>:<span class="number">170</span>)</span><br><span class="line">        at java<span class="selector-class">.net</span><span class="selector-class">.SocketInputStream</span><span class="selector-class">.read</span>(SocketInputStream<span class="selector-class">.java</span>:<span class="number">141</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.util</span><span class="selector-class">.ReadAheadInputStream</span><span class="selector-class">.fill</span>(ReadAheadInputStream<span class="selector-class">.java</span>:<span class="number">101</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.util</span><span class="selector-class">.ReadAheadInputStream</span><span class="selector-class">.readFromUnderlyingStreamIfNecessary</span>(ReadAheadInputStream<span class="selector-class">.java</span>:<span class="number">144</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.util</span><span class="selector-class">.ReadAheadInputStream</span><span class="selector-class">.read</span>(ReadAheadInputStream<span class="selector-class">.java</span>:<span class="number">174</span>)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x000000076ef859b8&gt; (<span class="selector-tag">a</span> com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.util</span><span class="selector-class">.ReadAheadInputStream</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.MysqlIO</span><span class="selector-class">.readFully</span>(MysqlIO<span class="selector-class">.java</span>:<span class="number">3008</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.MysqlIO</span><span class="selector-class">.reuseAndReadPacket</span>(MysqlIO<span class="selector-class">.java</span>:<span class="number">3469</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.MysqlIO</span><span class="selector-class">.reuseAndReadPacket</span>(MysqlIO<span class="selector-class">.java</span>:<span class="number">3459</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.MysqlIO</span><span class="selector-class">.checkErrorPacket</span>(MysqlIO<span class="selector-class">.java</span>:<span class="number">3900</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.MysqlIO</span><span class="selector-class">.sendCommand</span>(MysqlIO<span class="selector-class">.java</span>:<span class="number">2527</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.MysqlIO</span><span class="selector-class">.sqlQueryDirect</span>(MysqlIO<span class="selector-class">.java</span>:<span class="number">2680</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.ConnectionImpl</span><span class="selector-class">.execSQL</span>(ConnectionImpl<span class="selector-class">.java</span>:<span class="number">2486</span>)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x000000076ef7b928&gt; (<span class="selector-tag">a</span> com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.JDBC4Connection</span>)</span><br><span class="line">        at com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.ConnectionImpl</span><span class="selector-class">.commit</span>(ConnectionImpl<span class="selector-class">.java</span>:<span class="number">1555</span>)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x000000076ef7b928&gt; (<span class="selector-tag">a</span> com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.JDBC4Connection</span>)</span><br><span class="line">        at org<span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.dbcp2</span><span class="selector-class">.DelegatingConnection</span><span class="selector-class">.commit</span>(DelegatingConnection<span class="selector-class">.java</span>:<span class="number">364</span>)</span><br><span class="line">        at org<span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.dbcp2</span><span class="selector-class">.DelegatingConnection</span><span class="selector-class">.commit</span>(DelegatingConnection<span class="selector-class">.java</span>:<span class="number">364</span>)</span><br><span class="line">        at org<span class="selector-class">.springframework</span><span class="selector-class">.jdbc</span><span class="selector-class">.datasource</span><span class="selector-class">.DataSourceTransactionManager</span><span class="selector-class">.doCommit</span>(DataSourceTransactionManager<span class="selector-class">.java</span>:<span class="number">279</span>)</span><br></pre></td></tr></table></figure><p>我拿着堆栈信息一通Google，最终发现下面这两个网页：<br><a href="https://bugs.mysql.com/bug.php?id=74739" target="_blank" rel="noopener">ReadAheadInputStream hangs on socket read</a><br><a href="https://bugs.mysql.com/bug.php?id=74979" target="_blank" rel="noopener">Server query cache vs protocol issue</a></p><p>啊哈，这个人的堆栈跟我们一样，这是MySQL的一个BUG。哈哈，我居然碰到了MySQL的一个BUG。似乎一个程序员在一个问题上调试了很久还没有找到原因时，总是急于把发现的蛛丝马迹套到某个相识的问题上，而且那个人跟我有着一样的运行堆栈！我现在多么希望就是这个原因啊！</p><p>在<a href="https://bugs.mysql.com/bug.php?id=74979" target="_blank" rel="noopener">Bug #74979</a>的说明中表示这个影响的版本是MySQL 5.7.4，但是我的MySQL 版本是5.7.14。为了确认是否是MySQL的问题，我专门找DBA来一起看这个现象。</p><p>起初，DBA也很诧异，SQL的执行速度是很快的，索引也没有问题，但是COMMIT很慢！这是为什么呢，我并不是MySQL专家，这么专业的事情还是主要交给DBA来分析。再和DBA复现了几次现象以后，DBA也有些纳闷了，再和其他的DBA沟通以后发现我的库所在的盘的IO很高，是磁盘IO的问题！WTF?!</p><p>DBA在给我的库换了一块盘以后一切恢复正常了，但是我此时的内心是这样的！</p><img src="/2017/06/21/记一次坑爹的Debug过程/啊.png"><p>这个例子告诉我，有时候再多的分析也没有，不要想太多，想把基本的监控参数看清楚很重要！哈哈，当然，我再这个过程中又学到了很多新技能，就算这次坑爹的Debug过程花了我快1天半的时间，但我还是觉得很值得！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天QA跟我反馈说系统有几个接口反应很慢，起初我不以为意，因为这几个接口就是简单的写入和删除，最多就是再更新一下缓存，能有多慢。我让QA看看是不是网络抖动，延迟的问题，再看看我们的&lt;code&gt;access_log&lt;/code&gt;里面响应时间是多少。QA说网络比较稳定，&lt;code&gt;access_log&lt;/code&gt;里面显示要好几秒，这就让我有些诧异了。其中有一个删除用户XXX数据的接口响应特别慢，我们在测试环境去复现的时候果然复现了这个问题。当前端直接点击删除的时候，接口过了8秒多才返回，这肯定不正常了，而且&lt;code&gt;access_log&lt;/code&gt;也印证了这一现象。&lt;/p&gt;
    
    </summary>
    
      <category term="debug" scheme="http://michael-j.net/categories/debug/"/>
    
    
      <category term="debug" scheme="http://michael-j.net/tags/debug/"/>
    
      <category term="调试" scheme="http://michael-j.net/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="mysql" scheme="http://michael-j.net/tags/mysql/"/>
    
      <category term="工具" scheme="http://michael-j.net/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>架构师应该是一种角色，而不是一个职位</title>
    <link href="http://michael-j.net/2017/06/03/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%BA%94%E8%AF%A5%E6%98%AF%E4%B8%80%E7%A7%8D%E8%A7%92%E8%89%B2%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E8%81%8C%E4%BD%8D/"/>
    <id>http://michael-j.net/2017/06/03/架构师应该是一种角色，而不是一个职位/</id>
    <published>2017-06-03T07:23:13.000Z</published>
    <updated>2017-06-03T15:09:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天看到一篇关于“架构师”的文章，读后非常有感触。我个人比较认同作者的大部分观点，故决定将原文进行翻译，和国内的开发者一起分享。原文地址：<a href="https://dzone.com/articles/architect-should-be-a-role-not-a-position" target="_blank" rel="noopener">“Architect” Should Be a Role, Not a Position”</a>。</p><a id="more"></a><p>当一个资深的开发者变得更加资深时会发生什么事情？他们经常会被提拔做去“架构师”。有时一个架构师也不一定非要是开发者，如果他们能看到更大的蓝图。最终，总有一个人挂着“架构师”的头衔：他对要开发的系统和正在开发的系统做出架构上决策。在一些更大的公司，还有“架构师议会”，每个团队指定的架构师们聚在一起决定着一些明智的事情。</p><p>但我认为专门设立“架构师”的职位是一个糟糕的想法。架构师应该是建筑行业的一个职位，这是说的过去的，因为你不能在项目中期改变和调整架构。但是软件架构是十分灵活的，不应该预先就严格地定义好。而且开发工作和架构设计是如此的紧密关联，所以说某个人决定“什么要做”和“什么不要做”是不科学的。这会带来各种各样的问题，主要是因为架构师经常无法全面的考虑到具体的实现是怎么样。如果一个架构师长时间不写代码，他们更加倾向于忽略“实现细节”，转而仅仅考虑抽象设计。然而，抽象总是伴随着遗漏，只考虑抽象而不考虑特定的实现这样的解决方案很少行得通。</p><p>我的第一个论点就是：在不知道详细地编写所有代码地情况下，你无法在成为一个优秀的架构师。大多数情况下都不是“简单地编码”。如果你已经成为架构师多年，同时也多年没有写过代码了，那几乎可以肯定你不是一个优秀的架构师。</p><p>当然，你可能是一个优秀的架构师。或许在你所在的那个特别的公司里，有人坐在象牙塔中，指挥着码农去整合这个实现那个，这可能说的过去。但即使是这种情况，也有更好的方法。</p><p>架构师应该是一种角色。每个资深的团队成员都可以也应该扮演架构师的角色，不用每个团队指定一个人来当。实际上，最好有多个人来扮演架构师。在会议中讨论架构设计和讨论功能设计类似，如果你是那个要实现所有事情的人，那么你需要带着明确的想法去参会。任何的过度设计（大部分架构师经常会犯这个错误）需要在你面前证明是合理的——“我是否愿意去写这些模板代码，或者是否有一种更简单优雅的实现方式”。</p><p>职位可以使“软件工程师”，但角色可以是“敏捷大师”、”架构师”、”持续集成官”，等等。如果公司需要一个“架构师议会”去决定系统间更宏观的整合，开发者可以提名某个人去参与这些会议，这个人有可能是对这些系统最了解的人。</p><p>我知道现在架构师在想什么——有一些更加高层次的关注点开发要么不太能理解要么不应该为此被打扰。大错特错！如果你的开发不理解更高层次的架构规划，那么迟早你会遇到问题的。是的，因为他们要让代码适应你正在规划的更大的蓝图，他们需要被打扰。</p><p>还有一方面于团队成员的态度和动态的交流。如果某个不是特别优秀或者受人尊敬的开发被提升为“架构师”，那么可能破坏团队的和谐。另一方面，某些人被提升为“架构师”以后可能会过于自信，以至于他们会想当然的去做出设计决定，而不管那些反对他们的好的争论点。</p><p>所以，理想的情况（这是我的第二个论点）是取消架构师的职位。确保你团队中资深的成员能够参与架构设计和决策，那样他们可能会更有干劲，他们也会对他们开发的成果有一个更加清晰的规划。最为重要的是，架构决策不能脱离日常的“现实”的开发环境，否则它们会不必要的复杂化。</p><hr><p>很久没有翻译了，有很多句子拿捏不准。如果有误翻的地方，还望指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天看到一篇关于“架构师”的文章，读后非常有感触。我个人比较认同作者的大部分观点，故决定将原文进行翻译，和国内的开发者一起分享。原文地址：&lt;a href=&quot;https://dzone.com/articles/architect-should-be-a-role-not-a-position&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“Architect” Should Be a Role, Not a Position”&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://michael-j.net/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="架构设计" scheme="http://michael-j.net/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="软件开发理论" scheme="http://michael-j.net/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>访问控制：为你的云上业务再加一把锁</title>
    <link href="http://michael-j.net/2017/06/01/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%B8%BA%E4%BD%A0%E7%9A%84%E4%BA%91%E4%B8%8A%E4%B8%9A%E5%8A%A1%E5%86%8D%E5%8A%A0%E4%B8%80%E6%8A%8A%E9%94%81/"/>
    <id>http://michael-j.net/2017/06/01/访问控制：为你的云上业务再加一把锁/</id>
    <published>2017-06-01T10:56:02.000Z</published>
    <updated>2017-06-03T02:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>企业上云首当其冲的就是要解决安全性的问题，是否满足企业对安全的诉求成了影响其是否上云的一个十分重要的因素之一。安全是一个很大的话题，从底层资源数据的安全到上层应用访问的安全，从访问客体（资源或服务）的安全到访问主体（人或者第三方服务）的安全，这些都属于安全的范畴之内。访问控制正是从资源访问的主客体关系出发，解决企业对资源访问的权限控制的需求。</p><p>维基百科对<strong><em>访问控制</em></strong>的定义如下：</p><blockquote><p>访问控制是指允许或禁止某人使用某项资源的能力。</p></blockquote><p>云环境下的访问控制使得这个问题变得复杂，我曾写过一篇<a href="http://michael-j.net/2017/03/07/%E5%AF%B9%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83/">对云环境下访问控制系统的思考</a>来阐述这个问题。从2.14号上线访问控制以来，接入访问控制的业务越来越多，截止目前已有六大业务支持访问控制；同时，访问控制还对云服务提供了支持，用户可以授权给易盾和视频云来访问其在NOS（网易对象存储）的数据资源。现在，你可以自定义访问控制策略，通过一套特定DSL语法来定义权限。根据自己的实际使用场景和组织架构来定义对权限的需求，这具有十分重要的意义。</p><p>举个例子，如果不允许某某子账号删除<code>avatar</code>桶中<code>file-1.png</code>的图片，而允许其对其他任何文件有所有的控制权限，那么可以定义如下的策略来达到这个目的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"statement"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"action"</span>: [</span><br><span class="line">                <span class="string">"comb:nos:DeleteObject"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"effect"</span>: <span class="string">"deny"</span>,</span><br><span class="line">            <span class="attr">"resource"</span>: [</span><br><span class="line">                <span class="string">"comb:nos:*:*:*:avatar/file-1.png"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"action"</span>: [</span><br><span class="line">                <span class="string">"comb:nos:*"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"effect"</span>: <span class="string">"allow"</span>,</span><br><span class="line">            <span class="attr">"resource"</span>: [</span><br><span class="line">                <span class="string">"comb:nos:*:*:*:*"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过语言来定义权限，用户将获得十分灵活的权限控制，当然也包含了细粒度的权限控制。使用DSL来定义权限的做法很早之前就存在了，可以追溯到2001年的<a href="https://en.wikipedia.org/wiki/XACML" target="_blank" rel="noopener">XACML</a>时代。目前主流的云计算厂商也均采用这种方式来描述权限。我们采用了业界相同的命名方式来降低用户的理解成本。这里对策略语法做一个简单的介绍。</p><p>策略语法就是有着一定约束关系的JSON格式数据，由<code>version</code>和<code>statement</code>两个部分组成。<code>version</code>目前只支持1，而<code>statement</code>则是描述策略的具体形式。<code>statement</code>由三个部分组成，<code>action</code>、<code>effect</code>和<code>resource</code>，这三个子句构成了访问控制最为核心的三个部分。</p><ul><li><code>effect</code>表示授权类型，只能是<code>allow</code>（允许）或者<code>deny</code>（拒绝）。</li><li><p><code>action</code>表示动作，组成结构为<code>product:service-name:action-name</code>。<code>product</code>目前只支持<code>comb</code>，<code>service-name</code>代表基础服务（蜂巢）下的服务，目前已支持的服务如下：</p><p>服务代号 | 服务名称<br>— | —<br>nos | 对象存储<br>nlb | 负载均衡<br>rds | 关系型数据库<br>mongodb | MongoDB<br>ncr | Redis缓存<br>cdn | CDN</p><p><code>action-name</code>表示具体动作的名称，例如nos支持<code>GetBucket</code>、<code>PutObject</code>等动作，cdn支持<code>CreateDomain</code>、<code>DisableDomain</code>等等，具体的动作请参考对应服务的文档。</p></li><li><p><code>resource</code>表示资源，组成结构为<code>product:service-name:region:az:account-id:resource-descriptor</code>。<code>product</code>和<code>service-name</code>和<code>action</code>中的意义相同，<code>region</code>表示地域，<code>az</code>表示可用域，目前只支持<code>*</code>，<code>account-id</code>是用户的主账号id，目前也只能填入<code>*</code>，<code>resource-descriptor</code>是具体资源的描述符。<code>resource-descriptor</code>根据具体的服务会有变化，整体上是树形结构的。例如：<code>bucket-1/file-1.png</code>可以表示nos中<code>bucket-1</code>的桶中的<code>file-1.png</code>文件，而<code>instance/nlb-1</code>可以表示nlb中实例名称为<code>nlb-1</code>的实例。具体的规则请参考对应服务的文档。</p></li></ul><p><code>statement</code>语句本身是一个Array，你可以在其中最多定义5条子句。这样就允许你将多条策略组合在一个策略里面，也可以根据需要将策略拆改，选择权在你手上。</p><p>通过上面的策略语言，企业完全可以根据自身的实际需要来定义权限，具有非常大的灵活性和自由度。如果你以前使用过其他云的访问控制产品，那么上手会很快。如果是第一次接触此类产品，也不用担心，我们提供了一个强大了“编译器”来检查你的策略语法是否合法，并提供简单直观的错误展示来帮你迅速定位问题，如下图所示。</p><img src="/2017/06/01/访问控制：为你的云上业务再加一把锁/compile_error.png" title="错误提示"><p>另外，访问控制还提供了了<code>子账号</code>、<code>组</code>和<code>角色</code>来满足企业对访问主体描述性的需求，企业可以根据自身的组织架构和研发模式来组合使用这些身份。</p><p>掌握了授权策略后，理解鉴权的执行流程也是很重要的。鉴权流程按照Deny优先原则执行，如果有显式的Deny，那么直接拒绝；如果有显式的allow，那么则允许，否则也拒绝。具体流程如下。</p><img src="/2017/06/01/访问控制：为你的云上业务再加一把锁/auth_flow.png" title="鉴权流程"><p>在授权时请遵循最小权限原则，即根据用户的需要，将刚好能满足其需求的权限赋予给他，这样有助于规避一些越权执行的问题。除此之外，最佳实践还包含及时收回用户不再需要的权限，尽量通过组和角色来授权等等。详细的文档可以参考访问控制的官方文档。</p><p>通过以上的介绍，不知道你是否对访问控制有一个大致的了解。如果还是有些云里雾里，那不如自己去动手定义一个属于自己的访问策略吧！</p>]]></content>
    
    <summary type="html">
    
      企业上云首当其冲的就是要解决安全性的问题，是否满足企业对安全的诉求成了影响其是否上云的一个十分重要的因素之一。
    
    </summary>
    
      <category term="云计算" scheme="http://michael-j.net/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="cloud" scheme="http://michael-j.net/tags/cloud/"/>
    
      <category term="访问控制" scheme="http://michael-j.net/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    
      <category term="DSL" scheme="http://michael-j.net/tags/DSL/"/>
    
      <category term="云计算" scheme="http://michael-j.net/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>评论从多说迁移到Disqus</title>
    <link href="http://michael-j.net/2017/05/21/%E8%AF%84%E8%AE%BA%E4%BB%8E%E5%A4%9A%E8%AF%B4%E8%BF%81%E7%A7%BB%E5%88%B0Disqus/"/>
    <id>http://michael-j.net/2017/05/21/评论从多说迁移到Disqus/</id>
    <published>2017-05-21T14:25:25.000Z</published>
    <updated>2017-05-21T14:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>建站以来一直使用多说作为评论系统，我还是非常喜欢国人做的评论系统，简单实用接地气。但是不盈利的商业软件最终只能关闭，这方面国内对盈利模式得探索要不国外落后太多了。</p><p>虽然切换到Disqus以后免不了被墙，但目前我确实还没有找到称心如意的评论软件。如果网友们有好的评论系统，不放留言给我推荐，叩谢！</p>]]></content>
    
    <summary type="html">
    
      本站的评论系统从多说迁移到Disqus
    
    </summary>
    
      <category term="生活" scheme="http://michael-j.net/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="blog" scheme="http://michael-j.net/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>对云环境下访问控制系统的思考</title>
    <link href="http://michael-j.net/2017/03/07/%E5%AF%B9%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://michael-j.net/2017/03/07/对云环境下访问控制系统的思考/</id>
    <published>2017-03-07T12:16:56.000Z</published>
    <updated>2017-06-03T03:28:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在，云计算市场已是一片红海，不论是国内还是国外的云计算市场竞争都相当激烈。主流的云计算厂商在争夺企业客户方面都不留余地，因为企业用户对云计算的发展有着极为重要的意义，尤其是大企业客户。可以毫不夸张的说，没有企业用户，云计算的发展绝不会发展的如此迅速。</p><p>企业上云首当其冲的问题就是安全性，安全性已经成为企业上云最大的障碍。这里的安全性不光是基础设施的安全和稳定，比如虚拟机的高可用、RDS的高可靠等等，也包括应用层面的安全性，如WAF、证书服务、加密服务等等，还包括因为企业本身的IT架构/研发架构的复杂性带来的资源管控方面的安全性需求。毫不夸张地说，谁解决好了企业的安全性诉求，那么他就能在这片红海中立于不败之地。</p><p>安全是一个很大的话题，我不敢妄谈。最近我在做访问控制方面的工作，故此分享一下我对这个领域的一点思考。访问控制是安全中一块，也是十分重要的一块。有些云计算提供商甚至都没有将其划归到安全的范围，可能是没有意识到访问控制的重要性。AWS中访问控制的产品是<a href="https://aws.amazon.com/cn/iam/" target="_blank" rel="noopener">IAM</a>，可以说是云计算厂商中做的最早也最为完善的一个。IAM在其的产品分类中有一个词我觉得形容该产品最为合适——“合规性“。其实访问控制就是满足企业用户对于合规性的需求，说白了就是规范企业用户对云计算资源的访问。</p><p>既然这是一篇关于访问控制的文章，那么我们先来看看关于访问控制的定义。</p><p>维基百科关于<strong><em>访问控制</em></strong>的定义是：访问控制是指允许或者禁止某人使用某项资源的能力。这个定义中有几个关键点需要留意：</p><ol><li>人</li><li>某项资源</li><li>允许/禁止</li><li>能力</li></ol><p>虽说维基百科关于访问控制的定义略显简陋，但是这个定义我觉得已经勾勒出了访问控制系统的大致形态。首先是人，访问控制的主体是人，所以其最为重要的使用群体是用户，那就是说这个系统是一个面向用户的系统。其次是某项资源，资源是访问控制的客体，某项的限定词则表明资源的具体形式是未知的。再次是允许/禁止，这是访问控制对外提供服务的最为直观的表现形式，用一个更为专业的名称来形容的话就是“鉴权”。最后是能力，为什么我把能力专门拿出来作为一个关键点来说，因为这是理论和实践的一个关键区分点之一。访问控制的理论为我们设计对应的系统和产品指明了方向，但是在生产环境中使用的还是遇到各种各样的现实问题。有一点需要特别注意的是，访问控制系统作为一个通用的公共服务，它需要提供的是一种能力，而不是针对特定环境和产品，否则只为沦为某个特定的专家系统。</p><p>维基百科关于【访问控制】的定义在理论层面已经颇为全面，然而从系统的设计到角度来看还缺少一个关键点，那就是——动作。这里的动作（可以也称之为操作）可以理解为具体系统所开放的能力，或者用户可以对系统执行的操作。例如，RDS产品需要开放<code>createDataBase\listDataBase\deleteDatabase</code>等等动作，又如NOS（网易对象存储）需要开放<code>listBucket\createBucket\listObject\putObject</code>等等动作。就算脱离云计算的环境，动作也是访问控制中不可缺少的要素之一，因为任何给人使用的产品都会伴随与人的交互，而这些交互的细粒度表现就是这些动作。</p><p>既然现在我们已经了解了访问控制的基本理论，那是否可以开始设计系统开始编码了呢？千万不要这么做，想清楚再做远比边做边想要节约时间。这听上去有点和现在的“敏捷开发“不太符合，实际上恰恰相反，”敏捷开发”虽然强调持续集成、快速迭代，但是这却是建立在前期良好的架构设计的基础之上的。言归正传，这是一篇关于访问控制实践探究的文章，在我们设计系统之前，先看看以前的访问控制系统一般是怎么做的。</p><h2 id="传统的访问控制模型"><a href="#传统的访问控制模型" class="headerlink" title="传统的访问控制模型"></a>传统的访问控制模型</h2><p>在访问控制系统的设计中，有两种设计模式是十分重要，也是得到广泛应用的，那就是访问控制列表（ACL）和基于角色的访问控制（RBAC）。</p><h4 id="1-访问控制列表（ACL）"><a href="#1-访问控制列表（ACL）" class="headerlink" title="1.访问控制列表（ACL）"></a>1.访问控制列表（ACL）</h4><p>访问控制列表是早期的一种访问控制技术，其原理十分简单，就是记录哪些用户对这个资源能进行哪些操作，有类似如下的二维表维护在文件中：</p><table><thead><tr><th>User</th><th>Create</th><th>Update</th><th>Query</th><th>Delete</th></tr></thead><tbody><tr><td>张三</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>李四</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>王五</td><td>×</td><td>×</td><td>√</td><td>×</td></tr></tbody></table><p>这种访问控制的方式好处显而易见，就是简单直观，易维护。这种设计在操作系统、路由器、交换机和工业控制系统中都得到了广泛的使用。不过，ACL的缺点也是显而易见的，那就是当用户、资源和操作组建增长时，维护这张表的代价会异常庞大，另外，这种设计模式将用户对资源的控制权限直接绑定，十分死板，灵活性不够，无法满足云环境下动态资源授权的需求。</p><h4 id="2-基于角色的访问控制（RBAC）"><a href="#2-基于角色的访问控制（RBAC）" class="headerlink" title="2.基于角色的访问控制（RBAC）"></a>2.基于角色的访问控制（RBAC）</h4><p>基于角色的访问控制将用户按其属性进行分类构建出一个个具体的角色，而将权限授权角色，用户通过扮演角色来间接地获取对应的权限。RBAC非常适合现实环境，尤其是企业，因为使用资源的使用者一般并不是资源的拥有者，资源的所有者属于企业。在云环境中更是如此，可能使用RDS的人是公司的开发或者PE，而RDS的归属者是对应的企业。RBAC从访问控制的主体的角度出发，很好使适应了企业的组织结构，同时也将用户和权限分离开了，用户只需要通过扮演不通的角色就能获得对应的权限，这种方式解决了云环境下动态授权的权限需求。</p><p>那是否RBAC能解决我们所有的问题了？显然不是。现实的问题往往是复杂的，不会像非黑即白这样简单。RBAC将人和权限分离的方法确实解决了一部分灵活性的问题，但是也增加了使用成本，同时它对细粒度的权限控制没有很好的应对之法。</p><h2 id="云环境下面临的挑战"><a href="#云环境下面临的挑战" class="headerlink" title="云环境下面临的挑战"></a>云环境下面临的挑战</h2><p>现在我们也知道了主流的访问控制模型一般是怎么做的了，那么如何应用在云环境中呢？我觉得在云环境下的访问控制系统主要面临以下几个挑战：</p><h4 id="1-资源标识的灵活性"><a href="#1-资源标识的灵活性" class="headerlink" title="1.资源标识的灵活性"></a>1.资源标识的灵活性</h4><p>访问控制的系统的立项一般都晚于云计算中的其他产品，因为它本身属于支撑产品。但随着其他产品形态组建完善，如何很好地描述各个产品的资源就成了一件非常令人头疼地问题。在一些IaaS的产品形态中，很大一部分是以实例(instance)的方式来提供服务的；而在某些PaaS的产品形态中，有些是实例的方式来提供服务，而又有一些有着很强的特殊性，比如上文提到的NOS，它们的资源描述是需要以树形方式来表达的。SaaS产品用统一的访问控制系统来管理一般不太可能，因为每个Software的产品形态和使用方式千差万别，你很难去做到统一。在对访问控制系统的设计过程中我发现了一个很有趣的现象，当你考虑的产品越接近应用层面（上层服务），访问控制系统就越接近专家系统。这样很好理解，越上层的服务它的特殊性越强，所以通用性越差，只能做成专家系统。</p><h4 id="2-细粒度的权限控制"><a href="#2-细粒度的权限控制" class="headerlink" title="2.细粒度的权限控制"></a>2.细粒度的权限控制</h4><p>访问控制系统的有一个比较困难的点，那就是细粒度的权限控制。这一点在访问控制模型中你找不到答案，它们只是在比较宏观的层面讨论了人和权限的关系。细粒度的权限控制是现实中存在的一个需求，比如一个企业有若干台虚拟机，有一些虚拟机用作webserver，而有一些虚拟机用作数据库，还有一些作为中间件服务器，比如Zookeeper等等。而使用这些虚拟机的人各不相同，他们能看到并操作的虚拟机也应该得到严格地监管，否则可能会引起安全事故。细粒度地权限控制关键点在于“多细”，越细致地控制会导致你的系统复杂度成倍增加，不利于的系统地可维护性。我的建议是只做到实例级别，但有一个例外，那就是对象存储。能做到多细的程度很大一部分取决于第一点中你地资源标识地方式，如果你的资源描述方式得当，那么更加细粒度地访问控制并不会增加你系统地复杂度。这个我会在下文中提到。</p><h4 id="3-身份的多样性"><a href="#3-身份的多样性" class="headerlink" title="3.身份的多样性"></a>3.身份的多样性</h4><p>如果一个云计算厂商想吃下一个大客户，满足其业务架构只是其一，还有一个十分重要的条件就是满足其组织架构。大企业绝对有实力也有能力解决其本身的业务架构，其实上不上云更多地是战略性的考虑，他们更加看重云服务的稳定性、安全性和可维护性。同时，其本身的组织架构也十分复杂，要想让其没有阻力地上云，解决其员工的身份问题首当其冲。所以现在主流的云厂商都会提供多种身份的表示方式，例如：子账号、组和角色。</p><h4 id="4-权限的描述方式"><a href="#4-权限的描述方式" class="headerlink" title="4.权限的描述方式"></a>4.权限的描述方式</h4><p>权限的描述方式也是十分重要的一个点，可以说这个点设计得好坏决定了你后期能否悠然地应对业务方的接入还是每天火急火燎地和各个业务方定协议定接口。我们知道所有需要访问控制的云产品必然有其支持的动作（Action），每个产品资源(Resource)的描述方式也各不相同，同时允许（Allow）还是禁止(Deny)针对某个资源的操作也是需要明确给出来的。这三个点构成了权限描述的三个要素。如果在前期的设计中没有充分思考这个问题，那么恭喜你，你很有可能给自己埋了一个深坑。你很有可能设计几张大表，来表示各个业务方支持的动作，资源以及用户和他们的关系。出现这样的设计是因为没有真正理解访问控制系统的业务领域。当你在设计这几张表的时候其实意味着访问控制系统在“理解”各个产品的功能，这对一个通用的访问控制系统是致命的。访问控制系统作为一个底层/共享的通用系统，对外输出地只能是能力，而不是去理解各个产品它们自己地业务领域。说到这里，我还是推荐所有的技术人员都有必要学习一下DDD的理论，就算不用自己写代码，系统性地学习其战略模式也会让你收益颇多。</p><h4 id="5-动态的授权体系"><a href="#5-动态的授权体系" class="headerlink" title="5.动态的授权体系"></a>5.动态的授权体系</h4><p>这一点相比以上4点来说要简单，这是因为如果你的访问控制系统已经很好地解决上面的挑战，那么你也就自然而然得获得了动态的授权体系。之说以是动态的，是因为云环境下用户和权限的关系往往不是一成不变的。用户在某个时刻希望获得A授权，而在另外一个时刻又希望获得B授权，而且有时授权还带有时效性，当过了截至时间授权也就自动失效了。这种动态性的需求是真实存在的，但我认为满足这个需求依赖于针对前4点的设计，如果把前面的设计做好了，那么系统也就自然而然地满足了动态性的需求，这是一个水到渠成的过程。</p><h2 id="业界是如何处理这个问题"><a href="#业界是如何处理这个问题" class="headerlink" title="业界是如何处理这个问题"></a>业界是如何处理这个问题</h2><p>说实话，当我去设计蜂巢的访问控制系统的时候并没有像现在考虑的这么全面。我意识到了一些问题的棘手性，也调研了现在业界做访问控制的方法，可以说做的最好的还是<a href="https://aws.amazon.com/cn/iam/" target="_blank" rel="noopener">IAM</a>。<br><a href="https://aws.amazon.com/cn/iam/" target="_blank" rel="noopener">IAM</a>将用户身份划归为子用户、组和角色，基本上这三种身份标识可以满足身份多样性的要求了。我觉得<a href="https://aws.amazon.com/cn/iam/" target="_blank" rel="noopener">IAM</a>关于权限描述的方式令我耳目一新，它使用了领域专用（DSL）语言来描述权限，具体的形式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>: &#123;</span><br><span class="line">    <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">    <span class="attr">"Action"</span>: <span class="string">"s3:ListBucket"</span>,</span><br><span class="line">    <span class="attr">"Resource"</span>: <span class="string">"arn:aws:s3:::example_bucket"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我第一次接触<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL</a>的概念，当时对这种设计模式是完全懵逼的，也不太理解其设计思想。随着考虑的问题越来越多，我发现了<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL</a>的强大之处。因为云环境下的访问控制系统最令人头疼的问题就是资源和权限的描述方式，这种极致的灵活性很难通过设计表格来获得。因为任何的以表为中心的设计方式都会映射到某个具体的领域模型上，又因为各个业务的权限控制各不相同，难道说我要根据各个业务来建立模型？前面也说过了，这是万万不可取的，这样设计只会让你深陷无尽的加班和调试之中。用<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL</a>来将访问控制和具体的权限理解分隔开了是最为合适的方式。</p><p>通过一套约定的DSL语法来描述权限，访问控制系统可以获得极大的灵活性，同时也不需要理解具体的权限。对权限的理解还是由各个业务方自己控制，这样系统就获得了最大程度的解耦。访问控制系统只用维护这套DSL语法就可以无限的扩展性，多么完美的方案啊！有时间我会专门写一篇关于DSL的文章来对其应用场景进行分析。</p><p>实际上，用DSL语法来描述权限也不是<a href="https://aws.amazon.com/cn/iam/" target="_blank" rel="noopener">IAM</a>首创，早在2001年就出现了响应的规范——<a href="https://en.wikipedia.org/wiki/XACML" target="_blank" rel="noopener">XACML</a>（可扩展的访问控制高标识语言），该规范现在已经发展到3.0了。其大致的鉴权流程如下图所示，如果对其原理由兴趣的同学可以查看对应的资料。</p><img src="/2017/03/07/对云环境下访问控制系统的思考/XACML.png" title="This image shows the XACML architecture and a sample authorization flow."><p>以上就是我对云环境下访问控制系统的一点理解，如有不严谨的地方，还望指正。总而言之，云环境下的访问控制系统面临的挑战很多，充分理解访问控制的原理有助于理解代码背后的意义，让我们的系统设计不至于走偏。基于<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL</a>的访问控制模型已经成为业界的主流，但各个云计算厂商自身的业务场景和面向目标人群又各有不通，如何制定适应自身环境的DSL成为了一个关键。后续有机会我会分享网易蜂巢在访问控制系统方面的实践。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://www.cec-ceda.org.cn/information/book/info_6.htm" target="_blank" rel="noopener">访问控制</a><br><a href="http://blog.csdn.net/bluishglc/article/details/6577778" target="_blank" rel="noopener">访问控制模型ACL和RBAC</a><br><a href="https://martinfowler.com/books/dsl.html" target="_blank" rel="noopener">DSL</a></p>]]></content>
    
    <summary type="html">
    
      最近我在做访问控制方面的工作，故此分享一下我对这个领域的一点思考。
    
    </summary>
    
      <category term="云计算" scheme="http://michael-j.net/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="架构设计" scheme="http://michael-j.net/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="cloud" scheme="http://michael-j.net/tags/cloud/"/>
    
      <category term="访问控制" scheme="http://michael-j.net/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    
      <category term="DSL" scheme="http://michael-j.net/tags/DSL/"/>
    
      <category term="云计算" scheme="http://michael-j.net/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot反序列对象失败</title>
    <link href="http://michael-j.net/2016/12/21/Spring-Boot%E5%8F%8D%E5%BA%8F%E5%88%97%E5%AF%B9%E8%B1%A1%E5%A4%B1%E8%B4%A5/"/>
    <id>http://michael-j.net/2016/12/21/Spring-Boot反序列对象失败/</id>
    <published>2016-12-21T02:21:55.000Z</published>
    <updated>2017-06-03T03:40:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在Spring Boot这个项目很火，尤其是微服务的流行，Spring Boot作为Java语言最热门的微服务框架之一，它极大地简化了Spring的配置过程。只需要一个注解就可以把整个工程拉起来，大大地降低了Spring的学习成本。我记得Spring Boot的某个开发人员说过，Spring Boot最令开发者激动的功能是可以自定义banner，哈哈，我也非常喜欢这个功能。</p><p>言归正传，开始介绍今天我遇到的一个诡异的问题。我使用Redis来缓存一些数据，但是这些数据在反序列的时候报错了。由于原工程涉及一些敏感信息，我新建了一个demo工程来说明这个问题。报错信息如下：</p><blockquote><p>java.lang.ClassCastException: com.netease.boot.dal.Product cannot be cast to com.netease.boot.dal.Product</p></blockquote><p>看到这个报错我就懵逼了，以致于我对了好几遍来确认眼睛没有看花。经过若干次重试，还是一样的错误。有人可能会对<code>Product</code>的实现产生怀疑，是不是没有加<code>serialVersionUID</code>，作为一个专业老司机，这点错误我还是不会犯得。我贴一下相关的代码：</p><p>Product类如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final long serialVersionUID = <span class="number">-5837342740172526607</span>L;</span><br><span class="line"></span><br><span class="line">    @Size(min = <span class="number">1</span>, max = <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> code;</span><br><span class="line">    @Size(min = <span class="number">1</span>, max = <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    @Size(max = <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> description;</span><br><span class="line">    @NotNull</span><br><span class="line">    <span class="keyword">private</span> EMailAddress principalEmail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product(<span class="keyword">String</span> code, <span class="keyword">String</span> name, <span class="keyword">String</span> description, EMailAddress principalEmail) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">        <span class="built_in">this</span>.principalEmail = principalEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void changeName(<span class="keyword">String</span> <span class="keyword">new</span><span class="type">Name</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="keyword">new</span><span class="type">Name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void changeDescription(<span class="keyword">String</span> <span class="keyword">new</span><span class="type">Description</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = <span class="keyword">new</span><span class="type">Description</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void changePrincipalEMail(EMailAddress <span class="keyword">new</span><span class="type">PrincipalEMail</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.principalEmail = <span class="keyword">new</span><span class="type">PrincipalEMail</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getDescription() &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EMailAddress getPrincipalEmail() &#123;</span><br><span class="line">        <span class="keyword">return</span> principalEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product&#123;"</span> +</span><br><span class="line">                <span class="string">"bizCode='"</span> + code + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", description='"</span> + description + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", principalEmail="</span> + principalEmail +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis service相关的代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">　　@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> put(<span class="keyword">String</span> <span class="built_in">key</span>, Serializable content) <span class="keyword">throws</span> RedisException &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = redisPoolConfig.getJedis();</span><br><span class="line">        <span class="built_in">byte</span>[] contentBytes = SerializationUtils.serialize(content);</span><br><span class="line">        jedis.<span class="built_in">set</span>(<span class="built_in">key</span>.getBytes(ENCODING), contentBytes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.error(<span class="string">"Put error:&#123;&#125;."</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            redisPoolConfig.releaseJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　@Override</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) <span class="keyword">throws</span> RedisException &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = redisPoolConfig.getJedis();</span><br><span class="line">        <span class="built_in">byte</span>[] valueBytes = jedis.<span class="built_in">get</span>(<span class="built_in">key</span>.getBytes(ENCODING));</span><br><span class="line">        <span class="keyword">if</span> (valueBytes == <span class="keyword">null</span> || valueBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SerializationUtils.deserialize(valueBytes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.error(<span class="string">"Get error:&#123;&#125;."</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            redisPoolConfig.releaseJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实在没办法，这尼玛是什么问题。因为我以前这么使用过，而且工作的非常好，为毛这次就不行了。没办法了，加debug代码，我让get方法返回Object，再外面强转，（冥冥中有一种感觉，像是泛型的问题）。修改后的代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) <span class="keyword">throws</span> RedisException &#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = redisPoolConfig.getJedis();</span><br><span class="line">            <span class="built_in">byte</span>[] valueBytes = jedis.<span class="built_in">get</span>(<span class="built_in">key</span>.getBytes(ENCODING));</span><br><span class="line">            <span class="keyword">if</span> (valueBytes == <span class="keyword">null</span> || valueBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">Object</span> o = SerializationUtils.deserialize(valueBytes);</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"Get error:&#123;&#125;."</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                redisPoolConfig.releaseJedis(jedis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在反序列化之后加断电debug，观察变量o，得到如下所示的图：<br><img src="http://7xnwpq.com1.z0.glb.clouddn.com/redis-deser.png" alt="redis-get"></p><p>WTF! IDE都识别出来了变量o是Product类型，但是后续的强转还是失败。经过我的测试发现所有的通过redis反序列化出来的类都有这个问题。万般无奈之下，我陷入了深深地沉思之中…之中…中…</p><p>我开始怀疑是序列化的姿势不对，但是为毛以前可以啊。不管了，先加一段测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Product product = <span class="keyword">new</span> Product(<span class="string">"comb"</span>,<span class="string">"蜂巢"</span>,<span class="string">"云计算基础设施产品"</span>,<span class="keyword">new</span> EMailAddress(<span class="string">"hzxx@corp.netease.com"</span>));</span><br><span class="line">        <span class="comment">/*FileOutputStream fileOutputStream = new FileOutputStream("/home/mj/work/product.data");</span></span><br><span class="line"><span class="comment">        fileOutputStream.write(SerializationUtils.serialize(policyContext));</span></span><br><span class="line"><span class="comment">        fileOutputStream.flush();</span></span><br><span class="line"><span class="comment">        fileOutputStream.close();*/</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/mj/work/product.data"</span>));</span><br><span class="line">        oos.writeObject(product);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*FileInputStream fileInputStream=new FileInputStream("/home/mj/work/product.data");</span></span><br><span class="line"><span class="comment">        byte[] rawPolicyContext=new byte[fileInputStream.available()];</span></span><br><span class="line"><span class="comment">        fileInputStream.read(rawPolicyContext);</span></span><br><span class="line"><span class="comment">        PolicyContext pc = SerializationUtils.deserialize(rawPolicyContext);</span></span><br><span class="line"><span class="comment">        System.out.println(pc);*/</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/mj/work/product.data"</span>));</span><br><span class="line">        Product pc = (Product) ois.readObject();</span><br><span class="line">        System.out.println(pc);</span><br></pre></td></tr></table></figure><p>在倒数第二行打点，截图如下：</p><p><img src="http://7xnwpq.com1.z0.glb.clouddn.com/diy-deser.png" alt="diy-deser"></p><p>没截图没毛病啊，很正常啊。我还专门测试了<code>SerializationUtils</code>版的序列化方式(把上面的注释去掉)，发现结果也很正常，这尼玛到底是怎么回事。实际上，<code>SerializationUtils</code>也就是jdk自带的<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>的简单封装。</p><p>在我走投无路之际，正准备研究<code>instanceof</code>的工作原理的时候，脑中闪过一道灵感——难道是classloader的问题？说干就干，debug得到如下情况：</p><p><img src="http://7xnwpq.com1.z0.glb.clouddn.com/classloader-1.png" alt="classloader-1"><br><img src="http://7xnwpq.com1.z0.glb.clouddn.com/classloader-2.png" alt="classloader-2"></p><p>终于发现问题所在了，原来两个classloader不一样，而<code>instanceof</code>是对同一个classloader而言的。再确定原因后，借助强大的google发现了这是Spring Boot DevTools的一个限制，相关的文档链接: <a href="http://docs.spring.io/spring-boot/docs/1.4.2.RELEASE/reference/htmlsingle/#using-boot-devtools-known-restart-limitations" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/1.4.2.RELEASE/reference/htmlsingle/#using-boot-devtools-known-restart-limitations</a></p><p>原话是这样的：</p><blockquote><p>Restart functionality does not work well with objects that are deserialized using a standard ObjectInputStream. If you need to deserialize data, you may need to use Spring’s ConfigurableObjectInputStream in combination with Thread.currentThread().getContextClassLoader().<br>Unfortunately, several third-party libraries deserialize without considering the context classloader. If you find such a problem, you will need to request a fix with the original authors.</p></blockquote><p>DevTools是Spring Boot中一个很有用的工具，可以自动帮你重启应用，而不用你每次重启应用来debug，提高了生产效率。具体的用法可以参考相关的文档。这里的限制条件说的很清楚了，重启功能不能和使用标准的<code>ObjectInputStream</code>来反序列对象一起使用，如果你非要使用，那么请从线程的上下文中来获取classloader。</p><p>看到这里我瞬间明白了。因为devtools使用两个classloader，你工程中使用的第三方jar包被一个叫”base”的classloader所加载，而你正在开发的代码被一个叫”restart”的classloader所加载。如果检测到你的classpath路径下文件有变化，restart就会重新加载你工程的类。这样做以后能提高你的类加载速度，这在开发阶段是很有用的一个功能。</p><p>既然知道了原因，就很好解决了。因为我目前的工程比较小，而且只是一个restful后端应用，所有devtools对我的应用帮组不大。注释掉devtools依赖后就解决了上面的问题。如果你想使用这个工具，同时又有反序列化的需求，有两种方式解决：</p><ol><li>自定义一个<code>ObjectInputStream</code>，重写<code>resolveClass</code>方法，也可以使用Spring提供的<code>ConfigurableObjectInputStream</code>类。然后从<code>Thread.currentThread().getContextClassLoader()</code>获取classloader就可以解决该问题。</li><li>配置<code>spring-devtools.properties</code>文件，把你使用的第三方序列化工具也加入<code>restart　classloader</code>的控制范围内就行了。</li></ol><p>这两种方法均可以在Spring Boot的官方文档中有详细描述：<a href="http://docs.spring.io/spring-boot/docs/1.4.2.RELEASE/reference/htmlsingle/#using-boot-devtools" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/1.4.2.RELEASE/reference/htmlsingle/#using-boot-devtools</a>。</p><p>总结，从发现问题到定位原因耗时两个多小时，还是要加强对基础概念的深入理解才能快速定位原因啊！</p><p>文本的示例demo我已上传到github，有兴趣的同学可以下载自己debug一下：<a href="https://github.com/mymonkey110/boot-demo.git" target="_blank" rel="noopener">https://github.com/mymonkey110/boot-demo.git</a></p><p>参考资料:</p><p><a href="http://docs.spring.io/spring-boot/docs/1.4.2.RELEASE/reference/htmlsingle/#using-boot-devtools" target="_blank" rel="noopener">Spring Boot官方手册</a><br><a href="https://github.com/spring-projects/spring-boot/issues/3805" target="_blank" rel="noopener">spring-boot issue</a><br><a href="http://stackoverflow.com/questions/30795262/redis-serialization-and-deserialization" target="_blank" rel="noopener">redis serialization</a><br><a href="http://stackoverflow.com/questions/37977166/java-lang-classcastexception-dtoobject-cannot-be-cast-to-dtoobject" target="_blank" rel="noopener">classcastexception</a></p>]]></content>
    
    <summary type="html">
    
      本文记录了一次我遇到的诡异的反序列对象失败的debug过程，希望对遇到该问题的读者有帮助。
    
    </summary>
    
      <category term="debug" scheme="http://michael-j.net/categories/debug/"/>
    
    
      <category term="debug" scheme="http://michael-j.net/tags/debug/"/>
    
      <category term="springboot" scheme="http://michael-j.net/tags/springboot/"/>
    
      <category term="deserialized" scheme="http://michael-j.net/tags/deserialized/"/>
    
      <category term="redis" scheme="http://michael-j.net/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>架构为什么会腐化</title>
    <link href="http://michael-j.net/2016/12/15/%E6%9E%B6%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%85%90%E5%8C%96/"/>
    <id>http://michael-j.net/2016/12/15/架构为什么会腐化/</id>
    <published>2016-12-14T16:33:22.000Z</published>
    <updated>2017-06-03T03:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>架构腐化一词我已经忘了从哪本书上看到的了，但是这个词给我留下了非常深刻的印象。关键在于“腐”一词，充分而又形象的描述了架构是怎样一步一步从简单清爽走向复杂污秽的。请允许我用“污秽”一词来描述一个糟糕的架构，因为糟糕的架构就像是一潭散发着臭味的淤泥，让你不想靠近，一旦涉入其中就会难以自拔，苦不堪言。</p><p>我相信所有的开发者都不希望自己的参与项目是一潭淤泥，但是为什么会出现这么多糟糕的架构呢？难道是项目最初的设计者经验不够，又或者项目开发周期太赶？我认识事实并非如此。现在，软件开发者的水平都普遍提高了，因为我们有前人那么多经验可以借鉴，连刚毕业的大学生也知道用MVC模式来搭建框架。难道是MVC模式太挫了，不够用，实际上80%的项目用MVC模式足以应对。那到底是什么原因导致了项目腐化呢？我认为有以下三个原因：</p><h3 id="1-不理解项目的业务价值"><a href="#1-不理解项目的业务价值" class="headerlink" title="1. 不理解项目的业务价值"></a>1. 不理解项目的业务价值</h3><p>实际上，几乎所有的软件（尤其是商业软件）都有其所属的业务价值，理解你所开发的软件的业务价值对项目的成功来说至关重要。我发现很多程序员对业务需求不屑一顾，而对那些所谓的非功能性需求盲目的崇拜和追捧，其实这是一种本末倒置的行为。</p><p>现实世界是一个商业的世界，而商业世界则会充斥着各种各样的业务逻辑。理解这些业务逻辑会极大地增加你的见识、拓宽你的视野。如果你是一个在金融行业工作的程序员，那么长时间在金融领域工作的精力将极大地提高你的市场竞争力。但是如果你不愿意花时间去学习金融领域的知识，而是去盲目的追求最新的技术，那么其实你是丢芝麻捡西瓜，浪费了这个行业带个你的附加价值。我不是不鼓励程序员瞎折腾，实际上我自己有时候也喜欢瞎折腾，倒腾一些新玩意，这视乎是程序员的一种天性。我的意思是说不要放弃了解自己所在行业/领域的知识视为不见，而盲目的追求其他的“高大上”的技术。</p><p>为什么说理解项目的业务价值至关重要呢，那是因为只有理解了其业务价值你才能识别出来这个项目的核心领域所在，这样这个项目才不会走偏。传统的软件开放流程中有一个非常重要的角色存在，叫做“业务分析员”，他的工作在项目的概要设计和详细设计解决十分重要。虽然我也没见过有专职的人员干这个，但是这却是非常重要的一个角色。他会帮你分析你的业务，和产品经理沟通，理解产品的真正意图。在这个沟通过程中，你的领域模型也就逐渐的清晰起来了，哪些是核心哪些是支撑部分也就清楚了。</p><p>有些程序员在接到产品需求后立马就开始工作了，吭哧吭哧地撸袖子上阵，我认为这是十分要不得的。接到产品需求的第一反应不是要想着我要建哪些表哪些字段，而是要多问问自己这个需求是干啥的，产品经理真正的意图是啥，为什么要我来做，跟我的系统有啥关系。千万不要盲从产品经理的话，实际上有些时候他们自己也不知道自己要干啥，为啥要这么干。这个时候必要的交流是不可少的，随着对话的深入，你和产品对真是的需求都会有着更深地认识。新人和实习生在这方面经验往往不足，此时最好找一个比较资深的程序员帮你梳理一下业务流程。</p><p>相反，如果你不知道你的系统的业务价值或者核心所在，什么需求你都来着不拒，那么恭喜你，你的系统正在腐化。当你在抱怨说“为什么这个业务要放在我这里”，“这个我有什么关系”之类的话的时候就可以闻到一丝“腐化”的闻到。你可能会说项目工期紧、人手太少、需求太多之内的外部原因，所以临时地先加到系统中搞一下。Ok，这没有任何问题。但是我还是要说，你知道你的系统的核心价值所在吗？如果你的回答是Yes，那么恭喜你，你是一名合格的程序员了。否则，你可能需要学习一下技术之外的东西的了－那就是沟通。</p><h3 id="2-过度设计"><a href="#2-过度设计" class="headerlink" title="2. 过度设计"></a>2. 过度设计</h3><p>软件开发的头号敌人就是复杂度。现在软件开发是如此的困难，动不动就有十几万行代码出现，但是现实世界就是如此的复杂，不会因为你采用某种架构或者奇淫巧技就能把代码行数降下来。好的架构设计会将系统的复杂度控制在一个合理的范围之内，因为人所能驾驭的代码行数最多也就几十万行，如果一个系统的代码行数达到百万行，那么这个系统就很危险了。现在微服务架构如此火爆，不得不说有这方面的原因。</p><p>如果你在设计一个新系统，那么我需要提醒你一定要控制好复杂度。一个好的系统的核心域往往是简单的、直观的，其他人很快就能理解其核心的工作原理。如果一开始系统设计的十分复杂，那么这个系统的扩展性就会很差，后续的维护将不可想象。但是是不是在设计之初就完全不考虑后续的变化了呢？我的建议是你只需要把你的核心领域模型建好，多问问自己系统最核心的价值是提供什么服务的，照着这个方向去设计，那么你的系统就不会走偏。灵活性和可扩展型往往只是领域模型的延伸，这是一个水到渠成的过程。</p><p>非要给个度的话，我认为5%刚刚好。不要出现超过5%的跟你本次需求无关的概念和行为，而且这5%还是你能确定在不久的将来就会使用的扩展。</p><p>还是那句话，好的设计往往是简单的，复杂是万恶之源。</p><h3 id="3-懒于重构"><a href="#3-懒于重构" class="headerlink" title="3. 懒于重构"></a>3. 懒于重构</h3><p>过度设计不好，完全不设计也不行，尤其是随着敏捷开发的流行，持续交付优于提前设计的思想逐步流行。现在软件交付速度是如此之快，很有可能刚刚设计好的系统，下个月就全变样了。应对这种变化的唯一方法就是持续重构。</p><p>没有任何设计能预料到未来的变化，代码可能会发生变化。新的功能会持续的添加进来，老的功能也在持续的改变。而且每次迭代或者交付，都可能会对核心领域产生影响。千万不要对这种影响视而不见，因为它在改变着你的领域模型。正确地方式是经常调整领域模型以适应新功能所带来的变化，虽然每次调整的幅度可能很小，但是这却能让你的领域模型处于健康的工作状态。没有领域模型或者系统在一开始就是完美的，之所以它们能在后续的迭代过程中良好的工作离不开不断地重构。</p><p>重构不是等到你的系统无药可救的时候才想到的事，而是应该在其不断开发过程中一直进行的工作。如果说持续交付提高了你系统的竞争力，那么持续重构则是这种竞争力的有力保障！</p><p>以上三点是我认为架构腐化最致命的原因，很多思想来源于<a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank" rel="noopener">DDD</a>、<a href="https://book.douban.com/subject/1229923/" target="_blank" rel="noopener">重构</a>和<a href="https://en.wikipedia.org/wiki/Agile_software_development" target="_blank" rel="noopener">敏捷开发</a>。linus torvalds曾经说过：</p><blockquote><p>Talk is cheap. Show me the code.</p></blockquote><p>我认为<em>Talk is not cheap</em>, 好的思想和开发方式价值连城，想好了再做会提高你的工作效率，从而提升你的生活品质。</p><p>这篇文章从下笔到完成，拖了半个多月了，期间琐事太多。对这个话题有兴趣的朋友我们可以留言讨论。</p>]]></content>
    
    <summary type="html">
    
      今天我想聊一下架构腐化的话题，分享一下我对于架构腐化的看法和应对之道。
    
    </summary>
    
      <category term="架构设计" scheme="http://michael-j.net/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="DDD" scheme="http://michael-j.net/tags/DDD/"/>
    
      <category term="架构设计" scheme="http://michael-j.net/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>值对象的威力</title>
    <link href="http://michael-j.net/2016/10/18/%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A8%81%E5%8A%9B/"/>
    <id>http://michael-j.net/2016/10/18/值对象的威力/</id>
    <published>2016-10-18T15:27:45.000Z</published>
    <updated>2017-06-03T03:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>值对象是DDD中非常重要的一种技术，掌握这种技术让你写代码事半功倍，体会到OO的精妙。如果你是一名Java程序员，我相信你或多或少地见过值对象了，只是你没有意识到而已。</p><p>引用维基百科的<a href="https://en.wikipedia.org/wiki/Value_object" target="_blank" rel="noopener">解释</a>：</p><blockquote><p>In computer science, a value object is a small object that represents a simple entity whose equality is not based on identity.</p></blockquote><p>字面意思就是，值对象是一个小对象，它代表着一个简单的实体，而实体的相等性不取决于它的ID。</p><p>刚刚接触OO编程的新手看完上面的解释相信直接是懵逼的，跟我接触这一概念时一样。如何理解值对象了，我还是举一个栗子。比如我们在做一个短信推送的服务，需要根据目标用户的手机号推送到相应的短信网关。我们定义了一个根据手机号推送短信的interface，很有可能我们是这么设计：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void sendMessage(<span class="keyword">String</span> phone, <span class="keyword">String</span> message) &#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(phone) &amp;&amp; phone.length()!=<span class="number">13</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"phone format error:"</span>+phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(phone.starts(<span class="string">"134"</span>)) &#123;</span><br><span class="line">        sendMessageToChinaMobileGateway(phone,message);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(phone.starts(<span class="string">"130"</span>)&#123;</span><br><span class="line">        sendMessageToChinaUnionGateway(phone,message);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(phone.starts(<span class="string">"189"</span>) &#123;</span><br><span class="line">        sendMessageToChinaTelecomGateway(phone,message);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"unknown phone range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的过程我们只考虑3个号码段，134(移动)\130(联通)\189(电信)，其他的号码短我们暂不处理。上面的处理方式有什么问题？ </p><p>如果我们的工程里面只有一个地方用的<code>phone</code>的概念，也只有一个地方对<code>phone</code>所属的号码短进行判断，那么没问题。上面的写法没有任何问题，因为它是一个简单问题。但是如果你在做一个短信推送的应用，在你的工程里面会只有一个地方会使用<code>phone</code>这个概念吗，也之有一个地方需要判断号码短吗？ 显然不可能。</p><p>有人可能会争论说，不就是判断号码归属吗？我可以搞一个类似<code>PhoneQueryService</code>之类的查询类，再提供一个<br><code>Operator queryBelong(String phone)</code>的interface不就搞定了吗？ 当然，这么做也没有问题。但是当你的问题域逐渐变得复杂的时候，你就会开始有些不舒服了。因为每一个出现<code>phone</code>的地方，你发现基本上都会需要<code>PhoneQueryService</code>，但是他们在代码上又是两个东西。这种做饭的滥用最终会导致<code>Fat Service</code>的出现，代码的复用性会急剧降低。</p><p>究其原因，是因为我们把<code>phone</code>这个概念和<code>phone</code>的行为给拆开了。你可以用<code>String</code>代表任何字符类型，可以是<code>phone</code>，也可以是<code>name</code>，基本上这种类型可以代表任何东西。使用你API的人无法从中得到任何信息，除了你把变量名称叫做<code>phone</code>以外。同时，判断手机号网段这个动作是和<code>phone</code>本身强相关的，为什么不把这个动作加到<code>phone</code>里面了？！ 现在，我们重构一下代码，得到类似下面的代码结构：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!validate(phoneNumber)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"phone format error:"</span>+phone);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String phoneNmber)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//验证逻辑</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> phoneNumber.<span class="title">starts</span><span class="params">(<span class="string">"134"</span>)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isUnion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">return</span> phoneNumber.<span class="title">starts</span><span class="params">(<span class="string">"130"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isTelecom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> phone.<span class="title">starts</span><span class="params">(<span class="string">"189"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">getRawPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isSameWith</span><span class="params">(Phone other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other!=<span class="keyword">null</span>&amp;&amp;<span class="keyword">this</span>.phoneNumber.equals(other.getRawPhone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新增了一个叫<code>Phone</code>的类，并加入了判断网段归属的逻辑。引入这个类以后<code>sendMessage()</code>发生了什么变化呢？</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void sendMessage(Phone phone, <span class="keyword">String</span> <span class="keyword">message</span>) &#123;</span><br><span class="line">    checkNotNull(phone);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(phone.isMobile()) &#123;</span><br><span class="line">        sendMessageToChinaMobileGateway(phone,<span class="keyword">message</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(phone.isUnion())&#123;</span><br><span class="line">        sendMessageToChinaUnionGateway(phone,<span class="keyword">message</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(phone.isChinaTelecom()) &#123;</span><br><span class="line">        sendMessageToChinaTelecomGateway(phone,<span class="keyword">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咋一看，代码好像没有怎么减少啊。对于这个interface来说代码确实没有减少，反而我们还新加一个类。但是现在看看我们获得了什么：</p><ul><li>首先，方法签名变了。不在用String了，取而代之的是<code>Phone</code>类型。这对使用者的约束更强了，我们也再也不用判断phone是否合法了。</li><li>其次，判断网段归属和<code>phone</code>合在一起了，这样我需要判断归属运营商的时候直接调用<code>phone</code>的方法就行了。</li></ul><p>现在，我们已经得到了一个值对象了，那就是<code>Phone</code>。它是一个小对象，代表了手机号这个概念，它的相等性是基于其业务属性的，而不是ID，而且值对象根本就没有ID这个概念。</p><p>值对象最大的好处在于增加了代码复用，同时它也是类型安全的（这一点和我之前提到了enum类似）。如果你只在一个地方使用值对象，那么你是不会体会到值对象带来的好处的。但是，每当你的代码应用一次值对象，你就会收获值对象带来的好处。<strong><em>用的越多，收益越大</em></strong>，这一点和单元测试比较类似。使用值对象的另外一个好处就是前置的安全校验，尤其是你在编写SDK或者开放接口的时候。因为你无法知道使用者会如何使用你的API，那么通过值对象来获得一个前置的安全校验有着非常大的好处。</p><p>值对象用在什么地方呢？ 我个人的经验就是，如果在你的工程中反复出现一个具体的概念（往往跟现实生活有关），而且这个概念中涉及的行为是某种确定性的（比如你知道了手机号，就知道对应的运营商一样），那么你可以考虑一下值对象。引用《实现领域驱动设计》中关于值对象特征的定义:</p><ul><li>描述了领域中的一件东西</li><li>不可变的</li><li>将不同的相关属性组合成了一个概念整体</li><li>当度量和描述改变时，可以用另外一个值对象予以替换</li><li>可以和其他值对象进行相等性比较</li><li>不会对协作对象造成副作用</li></ul><p>最为重要的就是它描述了领域中的某件东西，并且它是不可变的。值对象一旦创建就不会发生变化，如果你需要表示另外一个东西，用另外一个值对象来代替它。</p><p>值对象是DDD中非常重要的部分，我们应该尽可能对使用值对象来建模，因为它是易于使用和替换的。但是值对象的实例化确实一个令人头疼的问题，尤其是聚合中存在1对多的关系时。由于这些内容涉及到DDD的多方面的知识，我不在这里展开讨论了。后续会专门讲值对象的持久化问题。之所以在讲DDD之前首先讲值对象，因为它还是少数几个可以完全脱离DDD并不失其威力的利器。就算你完全不了解DDD，也可以非常顺手的使用值对象。</p><p>说了这么多，我相信你也对值对象有个具象的认识了。纸上得来终觉浅，不如看看你现有的代码中哪些可以用值对象来代替吧！</p><p>参考文献：</p><p><a href="https://en.wikipedia.org/wiki/Value_object" target="_blank" rel="noopener">Wikipedia值对象的定义</a><br><a href="http://martinfowler.com/bliki/ValueObject.html" target="_blank" rel="noopener">Martin Fowler值对象的解释</a><br><a href="https://book.douban.com/subject/25844633/" target="_blank" rel="noopener">实现领域驱动设计</a><br><a href="https://www.infoq.com/presentations/Value-Objects-Dan-Bergh-Johnsson" target="_blank" rel="noopener">Power Use of Value Objects in DDD</a>: 强烈推荐</p>]]></content>
    
    <summary type="html">
    
      值对象是DDD中非常重要的一种技术，掌握这种技术让你写代码事半功倍，体会到OO的精妙。
    
    </summary>
    
      <category term="DDD" scheme="http://michael-j.net/categories/DDD/"/>
    
    
      <category term="DDD" scheme="http://michael-j.net/tags/DDD/"/>
    
      <category term="Value Object" scheme="http://michael-j.net/tags/Value-Object/"/>
    
  </entry>
  
  <entry>
    <title>论Enum的重要性</title>
    <link href="http://michael-j.net/2016/09/20/%E8%AE%BAEnum%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <id>http://michael-j.net/2016/09/20/论Enum的重要性/</id>
    <published>2016-09-20T14:18:11.000Z</published>
    <updated>2017-06-03T03:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道Java中有一种数据类型是枚举类，实际上很多强类型的语言都有枚举。但是很多人对枚举类不那么重视，或者不能正确地应用枚举，也就不能发挥其威力了。这里分享一下我对枚举的理解，及其常见的用法。</p><p>既然Java专门为枚举建立了类型，那么我们应该在什么时候去使用enum呢，我认为在以下两个场景中可以尝试使用。</p><h4 id="1-封装有限的的变化"><a href="#1-封装有限的的变化" class="headerlink" title="1. 封装有限的的变化"></a>1. 封装有限的的变化</h4><p>相信很多人都遇到这样一个场景，我们有一个父类，父类下面有几个子类，而这几个子类是可以确定的。我们并不想父类被不相干的类所继承，那么我们可以通过enum来限制子类。实际上你想把代码控制在预期的范围之类时，都可以通过enum来达到效果。</p><h4 id="2-状态代码"><a href="#2-状态代码" class="headerlink" title="2. 状态代码"></a>2. 状态代码</h4><p>我们经常会遇到使用状态码的情况，例如在任务处理过程中。我发现很多人喜欢使用int或者long来表示状态码，然后通过定义对应的变量来表示其意义。不是说这种方式不好，但我从中嗅出了一丝坏味道。如果通过int或者long来表示状态码，如果出现了不在业务范围内的值该怎么办？为什么状态码不能直接表示其意义，还需要通过文档来说明呢？我一直比较推崇Self-Explained的编程习惯，代码和文档合二为一。</p><p>那么使用Enum有什么好处了，我们为什么要用Enum呢？相比于int或者string，enum最大的优势就是有它是类型安全的。如何理解类型安全呢，我举一个例子：很多APP都有第三方登陆的功能，服务器要根据客户端传过来的登陆类型(type)来调用对应平台的接口来获取用户信息。我的代码是这样写的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TPAccountRouterImpl</span> <span class="keyword">implements</span> <span class="title">TPAccountRouter</span> &#123;</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"wbAccountResolver"</span>)</span><br><span class="line">    <span class="keyword">private</span> TPAccountResolver wbTPAccountResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"wxAccountResolver"</span>)</span><br><span class="line">    <span class="keyword">private</span> TPAccountResolver wxTPAccountResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"qqAccountResolver"</span>)</span><br><span class="line">    <span class="keyword">private</span> TPAccountResolver qqTPAccountResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TPAccount getAccountInfo(<span class="keyword">final</span> String tuid, String accessToken, AccountType accountType) <span class="keyword">throws</span> TPException &#123;</span><br><span class="line">        TPAccountResolver tpAccountResolver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (accountType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">WB:</span></span><br><span class="line">                tpAccountResolver = wbTPAccountResolver;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">WX:</span></span><br><span class="line">                tpAccountResolver = wxTPAccountResolver;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">QQ:</span></span><br><span class="line">                tpAccountResolver = qqTPAccountResolver;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="symbol">            default:</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TPException(<span class="string">"unknown account type"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpAccountResolver.getAccountInfo(tuid, accessToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TPAccountRouter</code>是一个账号解析的路由器，根据<code>AccountType</code>来调用对应平台的解析器来解析。配合switch-case语法，利用策略模式我们就可以写出一个还算优美的代码。如果把<code>accountType</code>换成<code>int</code>会怎样？那么我们不得不加上一句及其烦人的<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(accountType&lt;<span class="number">0</span> || accountType&gt;<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"type illegal"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护性代码，同时将case子句换成一个一个静态常量，最后还在API文档上配上说明，1,2,3各代表什么意义。我相信大家一定能感受出来两种代码写法带来的区别。</p><p>另外一个有点，我认为就是enum的self-explain特性，上面的例子中也直观的反应了这一点。Enum结合了int和String的优点，并将其发扬光大。</p><p>关于Enum怎么用，网上有很多的介绍，可以参考这篇文章：<a href="http://www.cnblogs.com/happyPawpaw/archive/2013/04/09/3009553.html" target="_blank" rel="noopener">http://www.cnblogs.com/happyPawpaw/archive/2013/04/09/3009553.html</a>，还是比较全面的。最常用的就是直接申明各个枚举值，基本上能满足大部分业务场景了。也有很多场景下，我们会在enum中加入成员变量，这是因为业务中存在和Enum相对应的文档和动作。再举一个我写过的代码例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCheckedException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3143228702981231790L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractCheckedException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ErrorCode <span class="title">errorCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode().code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode().msg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">successCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorCode.SUCCESS.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ErrorCode &#123;</span><br><span class="line">        SUCCESS(<span class="number">1000</span>, <span class="string">"success"</span>),</span><br><span class="line">        PARAM_ERROR(<span class="number">1001</span>, <span class="string">"parameter error"</span>),</span><br><span class="line">        ILLEGAL_REQUEST(<span class="number">1002</span>, <span class="string">"illegal request"</span>),</span><br><span class="line">        SYS_ERROR(<span class="number">1003</span>, <span class="string">"system error"</span>),</span><br><span class="line">        NAMESPACE_NOT_FOUND(<span class="number">2001</span>, <span class="string">"namespace not found"</span>),</span><br><span class="line">        NAMESPACE_ALREADY_EXIST(<span class="number">2002</span>, <span class="string">"namespace already exist"</span>),</span><br><span class="line">        APP_NOT_FOUND(<span class="number">2003</span>, <span class="string">"app not found"</span>),</span><br><span class="line">        APP_ALREADY_EXIST(<span class="number">2004</span>, <span class="string">"app already exist"</span>),</span><br><span class="line">        TASK_NOT_FOUND(<span class="number">2005</span>, <span class="string">"task not found"</span>),</span><br><span class="line">        TASK_ALREADY_EXIST(<span class="number">2006</span>, <span class="string">"task already exist"</span>),</span><br><span class="line">        CRON_EXPRESSION_ERROR(<span class="number">2007</span>, <span class="string">"cron expression error"</span>),</span><br><span class="line">        ZOOKEEPER_ERROR(<span class="number">3001</span>, <span class="string">"zookeeper error"</span>),</span><br><span class="line">        NODE_NOT_EXIST(<span class="number">3002</span>, <span class="string">"node not exist"</span>),</span><br><span class="line">        NODE_ALREADY_EXIST(<span class="number">3003</span>, <span class="string">"node already exist"</span>),</span><br><span class="line">        UNKNOWN_ERROR(<span class="number">9999</span>, <span class="string">"unknown error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">        ErrorCode(<span class="keyword">int</span> code, String msg) &#123;</span><br><span class="line">            <span class="keyword">this</span>.code = code;</span><br><span class="line">            <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorCode <span class="title">getErrorCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (ErrorCode it : ErrorCode.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it.code() == code) &#123;</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我在<a href="https://github.com/mymonkey110/jscheduler" target="_blank" rel="noopener">jscheduler</a>中封装了高层了受检异常，这点收到了Zookeeper中<code>KeeperException</code>的启发。我在ErrorCode中加入了code和message，因为code和message是和这个枚举绑定的，放到枚举中再合适不过呢，我将之称为文档的绑定。还有情况是因为业务动作和枚举相关，比如第三方登陆的例子，我们完全可以第三方登陆接口的URL放到<code>AccountType</code>中，然后后续的解析方法直接从中取的URL进行调用就行，因为这个解析方法是和Enum一一对应的。这样的例子实在太多了，不胜枚举。</p><p>总之，如果你有一类相识的业务场景，并且这些业务场景只有有限的变化，是可以预期的，那么建议你考虑一下使用Enum。相信我，它值得尝试！</p>]]></content>
    
    <summary type="html">
    
      Enum是Java中非常重要的一种数据类型，用好Enum是写好代码必须掌握的技术。
    
    </summary>
    
      <category term="Better code" scheme="http://michael-j.net/categories/Better-code/"/>
    
    
      <category term="enum" scheme="http://michael-j.net/tags/enum/"/>
    
      <category term="OO" scheme="http://michael-j.net/tags/OO/"/>
    
      <category term="代码技巧" scheme="http://michael-j.net/tags/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>DDD-复杂问题解决之道</title>
    <link href="http://michael-j.net/2016/09/18/DDD-%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/"/>
    <id>http://michael-j.net/2016/09/18/DDD-复杂问题解决之道/</id>
    <published>2016-09-18T14:09:45.000Z</published>
    <updated>2017-06-03T03:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>上个星期在团队内部进行了关于DDD的分享，分享链接：<a href="http://slides.com/fengchen/ddd-tackling-complex-problem#/" target="_blank" rel="noopener">http://slides.com/fengchen/ddd-tackling-complex-problem#/</a>。</p><p>分享的过程中发现还是有很多小伙伴对DDD不太了解，或者一知半解。DDD其实不是一个新的技术，实际上距离Eric Evans出版《Domain Driven Design》已经12年了。与其说DDD是一门编程技术，我更愿意将它称之为软件开发方法。我发现国内的技术分享两级分化比较严重，要么太过高大上——关于架构、新技术之类，要么太底层——关于数据库优化、底层性能优化之类，但很少有人来讲中间的那一层——软件编程方法。</p><p>在我看来，一个新人要成长为技术大牛，都要经历下面三个阶段：</p><h3 id="1-Make-It-Work-（1-2-年）"><a href="#1-Make-It-Work-（1-2-年）" class="headerlink" title="1. Make It Work （1~2 年）"></a>1. Make It Work （1~2 年）</h3><p>刚刚踏入职场的新手程序员往往处于这个阶段，他们首要的工作是要让系统能正常工作。出于工作的需要，他们开始了解语言、框架、数据库、缓存。如果在大公司的话，可能会更早的接触服务框架、中间件等。但是他们的主要工作还是实现业务需求，对代码的质量没有过多的要求。有时候可能感觉到现在的写法可能不太好，但是又不知道怎么去组织代码才能让它们看上去更舒服，经常会刚到迷茫，好像刚工作一年就看到了未来十年的影子，这是十分令人沮丧的。这个阶段一般会持续1~2年。</p><h3 id="2-Write-better-code-3-5-年"><a href="#2-Write-better-code-3-5-年" class="headerlink" title="2. Write better code (3~5 年)"></a>2. Write better code (3~5 年)</h3><p>这个阶段是新手程序员向老司机转变的一个时机。他们已经能独立完成常见的业务需求，并给出自己的意见。写出的代码不仅是为了完成功能，更多地是在寻找一种平衡的美。这种美很难言明，它是介于现实逻辑和代码组织的一种完美结合。正好我也处于这个阶段，我会有时因为一次完美的解耦而欣喜，也会因为业务的妥协而忧伤。在这个时期，我在寻找一种“术”，一种能随心所欲驾驭代码的术。我开始了解到OO技术的精妙，开始理解设计模式的妙用，学着掌控整个项目的发展，只为达到软件的最高境界——“可复用”。这个阶段肯能持续时间很长，因为我们要细细去品味优秀代码的味道并为己所用，这需要时间的沉淀。</p><h3 id="3-Create-suitable-architect-5年"><a href="#3-Create-suitable-architect-5年" class="headerlink" title="3. Create suitable architect (5年 ~ )"></a>3. Create suitable architect (5年 ~ )</h3><p>当你能随心所欲的操纵代码时，你就会去寻找你还未涉及的阶段。这个阶段可能会产生多种分化，你可能会对项目的整体架构产生兴趣而走上架构师的道路，也可能对某些专有技术情有独钟而成为某一方面的技术专家。不论后面的发展方向如何，此时代码对你已经不是问题了，而成为了你的“工具”。国内的技术分享往往也集中在这个层面。好的架构往往有着相似的部分，但是每个架构又有它独有的业务背景，你需要剥离其中的业务部分，找出能为自己的项目有用的设计。没有完美的架构，只有最合适的架构，任何现实的架构都充满着妥协和折中。这个阶段持续时间可能更长，你也需要机缘能参与几个重大项目的架构设计。</p><p>说白了，软件开发还是一门需要经验的行业。我并不太相信天才的存在，因为没有长时间浸泡在代码之中项目之中，你是很难理解代码和业务的关系的，这需要大量的时间。现在“新技术”层出不穷，我的建议是，在没有成为真正的架构师之前，不要盲目的追逐这些“新技术”，这只会耗费你大量的精力。</p><p>言归正传，我认为DDD是一门教你Write better code的软件开发方法。就算你是底层的研发人员，我相信你也会从中收益。如果你是一名业务程序员（80%的都是），为什么不多花一些时间去真正理解你的业务呢？不要再去追逐那些“新技术”，多去思考一下我的代码该如何解耦、业务如何切分、代码怎么写才能更好的复用。如果你坚持这么做，我相信不出两年你对技术和业务的理解会发生质变。</p><p>学习DDD其实还是有一定的曲线的，如果你的团队中已经有人尝试过DDD了不妨向他取经，因为DDD的精髓更多的在于编程的思想，而不在于具体的代码。后期我会分享一些关于DDD、OO、Microservice方面的心得，如果你有这方面的心得和困惑也可以与我交流，分享是技术人成长的很重要的途径。</p><p>近期，我换了工作，加入了网易蜂巢团队。以前上研究生的时候就搞云计算，想不到时隔两年之后，又加入了云计算的浪潮之中，也算是殊途同归。</p>]]></content>
    
    <summary type="html">
    
      本文分享了我对于DDD的观点和对程序员成长的认识。
    
    </summary>
    
      <category term="DDD" scheme="http://michael-j.net/categories/DDD/"/>
    
    
      <category term="DDD" scheme="http://michael-j.net/tags/DDD/"/>
    
      <category term="感悟" scheme="http://michael-j.net/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper:distributed process coordination中文版</title>
    <link href="http://michael-j.net/2016/08/02/Zookeeper-distributed-process-coordination/"/>
    <id>http://michael-j.net/2016/08/02/Zookeeper-distributed-process-coordination/</id>
    <published>2016-08-02T08:53:05.000Z</published>
    <updated>2016-08-15T15:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用zookeeper比较多，但是国内关于zookeeper方面的数据太少。能介绍其使用同时也讲解原理的书太少了。Zookeeper:distributed process coordination是一本关于zookeeper不可多得的好书。读完以后我对zookeeper有能一个非常直观的了解。</p><p>现在分布式应用开发越来越常见，基本上大部分的分布式应用都需要与其它应用进行协同。Zookeeper非常擅长于处理分布式协同。所以我决定利用工作之余的时间翻译这本书籍，完全出于个人兴趣。</p><p><img src="/images/zookeeper/zookeeper.jpg" alt="zookeeper:distributed process coordination"></p><p><a href="https://www.gitbook.com/book/mymonkey110/zookeeper-distributed-process-coordination" target="_blank" rel="noopener">GitBook阅读地址</a></p><p><a href="https://github.com/mymonkey110/zookeeper-book/blob/master/SUMMARY.md" target="_blank" rel="noopener">GitHub阅读地址</a></p><p>由于本人第一次翻译技术书籍，肯定会有很多翻译不当的地方，欢迎大家能及时指正。如果有对本书翻译有兴趣的小伙伴，可以通过以下方式参与贡献：</p><p>参与讨论：邮件列表：<a href="mailto:&#122;&#x6b;&#95;&#116;&#114;&#x61;&#x6e;&#115;&#108;&#97;&#116;&#x6f;&#x72;&#64;&#103;&#114;&#111;&#x75;&#112;&#115;&#x2e;&#49;&#x36;&#x33;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#122;&#x6b;&#95;&#116;&#114;&#x61;&#x6e;&#115;&#108;&#97;&#116;&#x6f;&#x72;&#64;&#103;&#114;&#111;&#x75;&#112;&#115;&#x2e;&#49;&#x36;&#x33;&#46;&#99;&#111;&#x6d;</a>，申请加入地址：<a href="http://163.fm/UJNWGHS" target="_blank" rel="noopener">http://163.fm/UJNWGHS</a></p><p>部分贡献：通过issue进行讨论，如果通过，我会进行修改。这种方式我无法统计贡献者的名字，建议使用下面的方式参与翻译。</p><p>在 GitHub 上 fork 到自己的仓库，如 user/zookeeper-book，然后 clone 到本地，并设置用户信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:user/zookeeper-book.git</span><br><span class="line">$ cd zookeeper-book</span><br><span class="line">$ git<span class="built_in"> config </span>user.name <span class="string">"yourname"</span></span><br><span class="line">$ git<span class="built_in"> config </span>user.email <span class="string">"your email"</span></span><br></pre></td></tr></table></figure><p>修改代码后提交，并推送到自己的仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment">#do some change on the content</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -am <span class="string">"Fix issue #1: change helo to hello"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></table></figure><p>在 GitHub 网站上提交 pull request。<br>定期使用项目仓库内容更新自己仓库内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add upstream https://github.com/mymonkey110/zookeeper-book.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch upstream</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase upstream/master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -f origin master</span></span><br></pre></td></tr></table></figure><p>PS: 2016/8/15 Update:</p><p>很遗憾，因为授权的问题，不得不停止翻译的工作。本书已经有中文版的译本了，我后来才得知，所以我也不会取得中文版的翻译授权了。因为本人第一次翻译，事先没有搞清这些事情，才导致了现在的情况。不得不说，十分遗憾，感谢关注本书翻译的伙伴。我相信已有的中文译本应该还不错，如果需要的伙伴可以去购买。So, that’s it, it’s over, thanks for your attention.</p>]]></content>
    
    <summary type="html">
    
      Zookeeper:distributed process coordination中文译本。
    
    </summary>
    
      <category term="翻译" scheme="http://michael-j.net/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="zookeeper" scheme="http://michael-j.net/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>让百度索引你的github的博客</title>
    <link href="http://michael-j.net/2016/06/23/%E8%AE%A9%E7%99%BE%E5%BA%A6%E7%B4%A2%E5%BC%95%E4%BD%A0%E7%9A%84github%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://michael-j.net/2016/06/23/让百度索引你的github的博客/</id>
    <published>2016-06-23T08:53:05.000Z</published>
    <updated>2016-08-14T12:53:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉中，写博客是一件很潮的事情，尤其是程序员。自然，我也是其中的一员。博客无非两种类型，一种是动态类型的，以Wordpress为代表；另外一种则是存静态的，以Hexo, Jekyll为代表。现在，程序员都喜欢把博客托管在github上。一来省去了买虚拟主机的费用，二来可以通过git工具来管理博客，用起来十分方便。我的博客就是用hexo搭建的。</p><p>首先，github是不支持动态博客的，它只能托管存静态的网页，也就是说你只能放置一些html,js,css,jpg,png…之类的静态文件。其次，github屏蔽了百度的爬虫，也就是说百度不能索引你的博客内容。虽说程序员基本上都用google，但是你肯定还是想能被百度搜索到的。想知道自己的博客是否被索引可以这样查询，在搜索引擎中输入：site: 你的博客域名。</p><p>解决github屏蔽百度爬虫的思路就是“迁出”我们的博客，让百度爬虫不直接访问github就行了。</p><h2 id="方案一：利用CDN制作镜像网站"><a href="#方案一：利用CDN制作镜像网站" class="headerlink" title="方案一：利用CDN制作镜像网站"></a>方案一：利用CDN制作镜像网站</h2><p>我们知道cdn能缓存静态资源，如果我们利用cdn制作我们的镜像网站，再将百度索引的解析cdn上，那么爬虫就不会访问github服务器了，而是访问cdn缓存服务器。国内最火的cdn服务商就是七牛和又拍云了。我发现七牛不支持自动回源功能，而又拍云在这方面做得比较好，我们可以使用又拍云来做为我们博客的镜像网站。</p><p>我以本站为例，讲一下配置的流程：</p><h4 id="1-创建服务"><a href="#1-创建服务" class="headerlink" title="1. 创建服务"></a>1. 创建服务</h4><p>   <img src="/images/baidu_index/3.pic_hd.jpg" alt="创建服务"></p><h4 id="2-配置回源"><a href="#2-配置回源" class="headerlink" title="2. 配置回源"></a>2. 配置回源</h4><p>   <img src="/images/baidu_index/5.pic_hd.jpg" alt="配置回源"></p><h4 id="3-绑定域名"><a href="#3-绑定域名" class="headerlink" title="3. 绑定域名"></a>3. 绑定域名</h4><p>完成上面的操作后，又拍云会自动分配一个域名给我。此时，我们就需要绑定自己的域名。添加需要绑定的域名：</p><p>   <img src="/images/baidu_index/5.pic.jpg" alt="绑定域名"></p><p>如果你希望博客能以www的方式来访问，那你还需要添加www的二级域名</p><h4 id="4-配置解析"><a href="#4-配置解析" class="headerlink" title="4. 配置解析"></a>4. 配置解析</h4><p>添加完域名绑定后，此时我们就只需要配置dns解析到又拍云了。我使用的是阿里云的域名系统，下图就是我设置的域名解析配置。</p><p>   <img src="/images/baidu_index/6.pic_hd.jpg" alt="配置解析"></p><p>因为github在国外访问速度还是很快的，所以对于海外的用户直接访问github就可以了，不用再访问又拍云了。<br>添加解析后一般需要几分钟才生效，看自己添加的域名dns解析生效了没有可以使用nslookup命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/blog  ᐅ nslookup michael-j.net</span><br><span class="line">Server:<span class="number">192.168</span>.<span class="number">199.2</span></span><br><span class="line">Address:<span class="number">192.168</span>.<span class="number">199.2</span>#<span class="number">53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">michael-j<span class="selector-class">.net</span>canonical name = mj-blog<span class="selector-class">.b0</span><span class="selector-class">.aicdn</span><span class="selector-class">.com</span>.</span><br><span class="line">mj-blog<span class="selector-class">.b0</span><span class="selector-class">.aicdn</span><span class="selector-class">.com</span>canonical name = ctn<span class="selector-class">.b9</span><span class="selector-class">.aicdn</span><span class="selector-class">.com</span>.</span><br><span class="line">Name:ctn<span class="selector-class">.b9</span><span class="selector-class">.aicdn</span><span class="selector-class">.com</span></span><br><span class="line">Address: <span class="number">183.134</span>.<span class="number">101.194</span></span><br></pre></td></tr></table></figure><p>  此时，我发现michael-j.net的域名已经成功解析到了又拍云。</p><ol><li>完成</li></ol><p>完成以上步骤后，你会收到又拍云发给你关于域名绑定通过的邮件。此时你就可以在浏览器中访问你的博客啦！</p><p>最关键的问题是，我们要验证百度是否能正常的抓取我们的博客？ 我们使用百度站长的测试工具来测试一下：</p><p>  <img src="/images/baidu_index/7.pic_hd.jpg" alt="抓取诊断"></p><p>哈哈，现在百度终于可以正常爬去我们的网站啦，接下来就是耐心的等待了，一般最多七天百度就会收录了。</p><h2 id="方案二：自己托管博客"><a href="#方案二：自己托管博客" class="headerlink" title="方案二：自己托管博客"></a>方案二：自己托管博客</h2><p>与利用cdn来制作镜像网站的思路一样，我们完全可以把博客托管在自己的服务器上，当然你得掏银子啦！💰 我个人觉得自己买一台属于自己的虚拟主机还是值得投入了，除了博客外你可以利用这台机器做很多事情，最低配的ecs也花不了多少钱，可以几个人合用一台。</p><p>Nginx是世界有名的反向代理服务器，同时它对静态文件的支持非常好，性能很高。我们完全可以利用Nginx来作我们博客的服务器。</p><h4 id="1-安装Nginx"><a href="#1-安装Nginx" class="headerlink" title="1. 安装Nginx"></a>1. 安装Nginx</h4><p>Ubuntu\Debian：<code>apt-get install nginx</code></p><p>Centos\Redhat: <code>yum install nginx</code></p><p>其他系统自行google</p><h4 id="2-配置Nginx"><a href="#2-配置Nginx" class="headerlink" title="2. 配置Nginx"></a>2. 配置Nginx</h4><p>在/etc/nginx/conf.d新作配置，一定要以<code>.conf</code>结尾。我新建名为<code>michael-j.net.conf</code>的配置文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">   <span class="attribute">server_name</span> michael-j.net;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">location</span> / &#123;</span><br><span class="line">     <span class="attribute">root</span> /home/michael/mymonkey110.github.io;</span><br><span class="line">     <span class="attribute">index</span> index.html;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">access_log</span> /var/log/nginx/michael-j.access.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意root是我们博客的目录，后面会提到。</p><h4 id="3-重启nginx"><a href="#3-重启nginx" class="headerlink" title="3. 重启nginx"></a>3. 重启nginx</h4><p>执行<code>nginx -s reload</code>生效</p><h4 id="4-自动下载博客内容"><a href="#4-自动下载博客内容" class="headerlink" title="4. 自动下载博客内容"></a>4. 自动下载博客内容</h4><p>我希望每次博客仓库有更新的时候能自动重建本地仓库，为此我专门写了一个工具git-watcher: <a href="https://github.com/mymonkey110/git-watcher" target="_blank" rel="noopener">https://github.com/mymonkey110/git-watcher</a>。当有新的内容push到你的仓库是，它会自动拉去并重建本地仓库。基本原理就是利用github的webhook功能，当有新的push事件发生时，github会发布相应的事件到指定的接口。git-watcher监听push事件，当接受到push事件去pull仓库。如果你觉得这个工具有点儿意思，Please star it.</p><h5 id="4-1-安装git-watcher-amp-git"><a href="#4-1-安装git-watcher-amp-git" class="headerlink" title="4.1 安装git-watcher &amp; git"></a>4.1 安装git-watcher &amp; git</h5><p><code>pip install git-watcher</code></p><p><code>apt-get install git</code></p><h5 id="4-2-启动git-watcher"><a href="#4-2-启动git-watcher" class="headerlink" title="4.2 启动git-watcher"></a>4.2 启动git-watcher</h5><p><code>git-watcher -u https://github.com/mymonkey110/mymonkey110.github.io.git -s 654321</code></p><p><code>-u</code>参数配置我们的博客仓库地址</p><p><code>-s</code>参数是我们webhook的secret key</p><p>git-watcher还支持其他一些参数配置，-h见说明</p><h5 id="4-3-配置dns解析"><a href="#4-3-配置dns解析" class="headerlink" title="4.3 配置dns解析"></a>4.3 配置dns解析</h5><p>将默认的dns解析到我们自己的主机上</p><p><img src="/images/baidu_index/10.pic_hd.jpg" alt="配置解析"></p><h5 id="4-4-配置webhook"><a href="#4-4-配置webhook" class="headerlink" title="4.4 配置webhook"></a>4.4 配置webhook</h5><p>进入仓库的<code>settings</code> －&gt; <code>Webhooks &amp; services</code></p><p>设置：<code>Payload URL</code>，这里输入我们主机的地址，这里只能用ip地址。同时，还要设置Secret，这个是用来签名body内容用的，一定要与git-watcher中配置一致</p><p><img src="/images/baidu_index/13.pic.jpg" alt="配置Webhook"></p><p>注意，我们只选择发送<code>push</code>事件就可以了。</p><h5 id="4-5-测试"><a href="#4-5-测试" class="headerlink" title="4.5 测试"></a>4.5 测试</h5><p>我们进行一些修改，然后push到博客的仓库，检测一下网站内容是否更新。如果正常更新，那说明已经大功告成了。这是可以再用百度的抓取工具进行诊断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决百度抓取github内容的问题基本思路都是让百度不直接访问Github，而是通过一个中间服务器来缓存内容。两种方式都需要付费，相对来说使用又拍云搭建镜像服务器在流量较小的情况下比较有优势，速度快，费用少；而自己租用主机在博客流量较大的时候比较经济，你可以选择按带宽计费的方式，同时你还获得了一台完全由你控制的主机，何乐而不为呢？！</p>]]></content>
    
    <summary type="html">
    
      Github屏蔽了百度的爬虫，导致众多托管在github上的博客无法进入百度的索引，损失了很多阅读量。本文分享一下解决这个问题的个人心得。
    
    </summary>
    
      <category term="生活" scheme="http://michael-j.net/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life blog" scheme="http://michael-j.net/tags/life-blog/"/>
    
  </entry>
  
  <entry>
    <title>博客域名更新：michael-j.net</title>
    <link href="http://michael-j.net/2016/06/17/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%96%B0/"/>
    <id>http://michael-j.net/2016/06/17/博客域名更新/</id>
    <published>2016-06-17T07:20:31.000Z</published>
    <updated>2016-08-20T10:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于备案原因😢，弃用老的域名michael-j.xyz,正式修改为：</p><p><strong><em><a href="http://michael-j.net">http://michael-j.net</a></em></strong></p><p>本博客主要纪录本人对技术、管理、生活的一些感悟。技术人一定要有沉淀，写博客是一个非常好的方式，我也经常鼓励团队中其他人写博客，记录自己的成长。</p><p>喜欢本站内容的同学可以加入收藏哦，也支持rss订阅！😊</p>]]></content>
    
    <summary type="html">
    
      博客域名正式更新为：michael-j.net
    
    </summary>
    
      <category term="生活" scheme="http://michael-j.net/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://michael-j.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Java异常的选择：Checked Exception还是Unchecked Exception ?</title>
    <link href="http://michael-j.net/2016/06/07/Java%E5%BC%82%E5%B8%B8%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <id>http://michael-j.net/2016/06/07/Java异常的选择/</id>
    <published>2016-06-07T07:20:31.000Z</published>
    <updated>2016-08-20T10:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>曾经听到过关于老司机和新手程序员的区别，其中最大的一个区别就在于异常的处理。新手程序员总是天真得把世界想得太美好，基本上没想过会出现异常的情况，而一个经验丰富的老司机会把最坏的打算考虑进去，给出相应的解决办法，使得发生异常时对系统的影响降低到最小。对此，我深表认同。现实的情况总是复杂的，而且还有很多不怀好意的人时刻准备攻击你的系统。使用你系统的用户越多，这种潜在的风险也就越大。</p><p>异常处理是应对这些风险的最强有力的武器。在Java的世界里，异常有两种：受检异常(checked exception)和非受检异常（unchecked exception）。想必所有的Javaer都使用过这两种异常，但是何时使用哪个异常缺失经常困扰程序员的头疼问题。在此，我分享一下自己的看法，如果你有不同的意见，请留意探讨。</p><h4 id="1-如果正常情况下会出现，那么使用Checked-Exception；反之，则使用Unchecked-Exception"><a href="#1-如果正常情况下会出现，那么使用Checked-Exception；反之，则使用Unchecked-Exception" class="headerlink" title="1.如果正常情况下会出现，那么使用Checked Exception；反之，则使用Unchecked Exception"></a>1.如果正常情况下会出现，那么使用Checked Exception；反之，则使用Unchecked Exception</h4><p>这条准则是我在决定使用Checked Exception还是Unchecked Exception的第一原则。如果API的使用者在正常使用的过程中都会出现异常，那么这种异常就属于Checked Exception。因为这种异常时属于程序执行流程众多分支之一，API的使用者必须意识到这种情况，并做出相应的处理。</p><p>举个栗子：</p><p>我希望向zookeeper中创建一个节点，那么这种情况就隐含了两个前提条件：</p><ul><li>父节点已经被创建（如果有的话）</li><li>本节点还未被创建</li></ul><p>那么，这个API的签名大致应该是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createNode</span><span class="params">(String path,<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> FatherNodeNotExist, NodeExist</span>;</span><br></pre></td></tr></table></figure><p>API的使用者看到这个签名的定义时就会得到一个强烈的心理暗示，我需要考虑父节点不存在和本节点已存在的情况，那么他就不得不显示的去处理这两种异常。</p><p>有的朋友可能会争论说，我正常的情况下不会出现这种情况，因为使用这个API的前提就是先创建好父节点，而后创建本节点，那我就不用抛出两种异常了，使用者也轻松了许多。但事实真的如此吗？我们想当然的认为了使用者是<code>自己人</code>，他们会乖乖的按照我们的想法去先创建父节点，再创建本节点，如果是在一个很局限的使用场景下，每个人都说经过严格培训的，那么你可以去做这样的假设，但是我还是不推荐你这么做，因为这样设计使得系统是脆弱的，不稳定的。如果能通过系统能自己避免这些错误，为什么不呢？况且，如果你把这个API开放给第三方的使用者，那么情况会更糟糕，你根本不知道他们会怎样去使用API，这非常恐怖！</p><p>有时候情况会变得很复杂，<code>正常情况</code>的鉴定变得很困难，你肯定会遇到这种时候，此时就需要结合你的业务场景去权衡其中的利弊。这依赖与你的经验和对业务场景的理解，我无法给你一个绝对的建议，那样是不负责任的。</p><p>我再举个常见的栗子：用户修改他拥有的资源信息。在菜谱APP中给出一个接口，让用户修改他菜谱的信息。那么这里一个隐含的条件就是用户修改他自己的菜谱信息，他是无权限修改别人的菜谱信息的。那么这个API的签名可能是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateMenu</span><span class="params">(<span class="keyword">long</span> menuId,<span class="keyword">long</span> uid,String title,String description...)</span></span>;</span><br></pre></td></tr></table></figure><p>如果用户尝试去修改不属于他的菜谱呢？我们是否需要throws UserPermissionException之类受检异常？我认为是不需要的。判断是这属于正常情况吗？我认为这不算是正常情况。<br>正常情况下，客户端调用修改信息的接口，那么menuId一定是属于这个用户的。如果出现这种情况，要么是你系统设计的就有问题，要么就是不怀好意的人在破坏你的系统。前者需要重新设计我们的系统，而后者我们更不用关系，直接抛出一个RuntimeException就可以，因为他不算正常用户。</p><h4 id="2-调用者中能从异常中恢复的，推荐使用受检异常；反之，则使用非受检异常"><a href="#2-调用者中能从异常中恢复的，推荐使用受检异常；反之，则使用非受检异常" class="headerlink" title="2. 调用者中能从异常中恢复的，推荐使用受检异常；反之，则使用非受检异常"></a>2. 调用者中能从异常中恢复的，推荐使用受检异常；反之，则使用非受检异常</h4><p>注意这里的一个关键词是<code>推荐</code>，决定使用哪种异常最为根本的还是第一条原则。如果第一条原则难以判断时，才考虑调用者。这条原则和<code>Effective Java</code>中的第58条很像，如果有这本书的朋友可以再拿出来读读。</p><p>我和<code>Effective Java</code>#58不同的观点在于，这条原则只能是<code>推荐</code>，另外，对于所有不能恢复的情况我都建议使用非受检异常。我对可恢复的理解是，如果API的调用者能够处理你抛出的异常，并给出积极的响应和反馈，并指导它的使用者做出调整，那么这就是可恢复的。不可恢复就是API的调用者无法处理你抛出的异常，或者仅仅只是打个LOG记录一下，不能对它的使用者做出提示，那么都可认为是不可恢复的。</p><p>还是最开始的栗子，如果调用<code>createNode</code>的调用者能响应<code>FatherNodeNotExist</code>，并把这种情况反应到终端上，那么使用受检异常是有积极意义的。对于不可恢复的情况，包括编程错误，我建议都是用非受检异常，这样系统能<code>fail fast</code>，把异常对系统的影响降到最低，同时你还能获得一个完整的异常堆栈信息，何乐而不为呢？！</p><p>基本上，这两条原则就能帮你决定到底是使用受检异常还是非受检异常了。当然，现实的情况很复杂，需要根据你所处的具体业务场景来判断，经验也是不可或缺的。在设计API的时候多问下自己这是正常情况下出现的吗，调用者可以处理这个异常吗，这会很有帮助的！</p><p>异常处理是一个非常大的话题，除了选择<code>checked exception</code>还是<code>unchecked exception</code>以外，还有一些一般的通用原装，例如：</p><ul><li>只抛出与自己有关的异常</li><li>封装底层异常</li><li>尽量在抛出异常的同时多携带上下文信息</li></ul><p>这些在<code>Effective Java</code>中都有详细的介绍，朋友可以认真读一下这本书，写的非常好！</p><p>对异常处理有不同理解的朋友可以给我留言，一起讨论，共同进步！</p><p>参考文献：</p><p><a href="https://github.com/HackathonHackers/programming-ebooks/blob/master/Java/Effective%20Java%20\(2nd%20Edition\" target="_blank" rel="noopener">Effective Java, 2nd Edition</a>.pdf)</p>]]></content>
    
    <summary type="html">
    
      java程序中经常会遇到异常的处理，何时选用Checked Exception和Unchecked Exception经常会让程序员苦恼，本文分享一下我在这方面的心得。
    
    </summary>
    
      <category term="Java" scheme="http://michael-j.net/categories/Java/"/>
    
    
      <category term="Java" scheme="http://michael-j.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>防范xss的正确姿势</title>
    <link href="http://michael-j.net/2016/04/12/%E9%98%B2%E8%8C%83xss%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>http://michael-j.net/2016/04/12/防范xss的正确姿势/</id>
    <published>2016-04-12T07:20:31.000Z</published>
    <updated>2017-06-03T03:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>xss攻击是web攻击中非常常见的一种攻击手段。如果你还没有听说过xss攻击，可以先了解xss的相关知识和原理，例如:<a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)" target="_blank" rel="noopener">https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)</a>。</p><p>防范xss攻击的方式也十分简单：转义！</p><p>但是转义的时机？是在持久化之前转义呢，还是读数据之后escape呢？</p><p>我开始想也没想就选择了第一种方式，因为这种方法看上去一劳永逸，但是我现在越来越倾向于第二种方式。</p><p>实际上选择第一种还是第二种需要根据你的实际情况来定。我们知道xss攻击是一种web攻击手段，它的运行环境是在用户的浏览器中，也就是说用户的运行环境是不可控的。那么在持久化之前进行转义看上去似乎不错，因为我们可以利用filter或者interceptor拦截所有的写入请求，统一进行转义。这样一来，我们的业务逻辑就完全不需要care转义的问题了，因为我们取到的数据已经都是转义的过的了。</p><p>如果用户的终端是可控的，比如：Native App，那么入库之前进行转义就显得多此一举，因为所有的输出方式都是在我们的App中展现的，自然也就不会出现了xss攻击的问题了。例如用户在评论中输入了<code>&lt;哈哈&gt;</code>，你觉得用户希望输出<code>&amp;lt;哈哈&amp;gt</code>;，还是<code>&lt;哈哈&gt;</code>呢？ 结果是显而易见的。</p><p>现实的情况往往是复杂的，不会只有黑和白、0与1、native和web，更多的是它们交织在一起，互相入侵对方的领域。基本上现在大部分的App都有分享功能，那么恶意的用户完全可以在评论中插入注入代码，再将该评论分享出去，那么其它被分享的用户就有被攻击的风险。解决的方法就是针对分享的数据进行全局转义，事实上已经很多模版系统已经帮我们考虑了这部分问题，例如Django和Jinja2的模版就是默认开启自动转义的。如果是前后端分离的场景，也可以有前端来进行escape。</p><p>我推荐使用“入库不转义读转义”还有一个原因，那就是前期转义格式的不确定性和后期输出的多样性。如果你正在正在开发一个rest服务器，你与App使用json格式通信。为了简单，在开始业务代码前，你对所有输入数据按照html格式进行转义。那么你可以十分放心分享出去的数据是安全的，因为所有的数据在持久化之前就已经转义了，同时你会痛苦unescape给App的数据。如果那天老板要求你以xml的格式输出这些数据（可能是其它系统的输入要求，也可能是打印报表），那么你会更加痛苦。因为xml和html的转义字符还是有些不同的，你不得不先unescape回原始数据然后再按照xml的格式escape一次。如果这样你觉得都还ok，那么我开始有点佩服你了。如果老板还要求你有更多的输出格式，那么你会更加痛苦，这还是在没有考虑输入格式变化的情况下。因为一个转义的问题导致逻辑变得复杂，影响系统的稳定性是得不偿失的。</p><p>最后，我总结一下这两种方式的优缺点：</p><table><thead><tr><th>转义方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>入库前转义</td><td>一劳永逸</td><td>需要针对多端进行不同的输出，灵活性不足，无法应对后期数据格式的变化</td></tr><tr><td>读取前转义</td><td>简单，灵活，能应对各种数据格式的场景</td><td>需要对每个输出数据转义，人工处理容易遗漏</td></tr></tbody></table><p>本人推荐第二种方式来防范xss攻击。虽然需要对每个输出数据都进行转义，但是如果你使用带自动转义的模版或者框架来处理的话，那么就可以极大的提高效率，又可以规避安全的问题。最后还是要提醒大家，安全无小事，即使你觉得没有人会攻击的系统，还是要规避这些风险，安全是系统的基石。</p><p>参考文献：</p><p><a href="https://n0tw0rthy.wordpress.com/2011/10/07/when-do-you-escape-your-data/" target="_blank" rel="noopener">Why escape-on-input is a bad idea</a></p><p><a href="https://n0tw0rthy.wordpress.com/2011/10/07/when-do-you-escape-your-data/" target="_blank" rel="noopener">When do you escape your data?</a></p>]]></content>
    
    <summary type="html">
    
      最近对xss攻击的的防范又有了新的理解，特此分享一下心得。
    
    </summary>
    
      <category term="安全" scheme="http://michael-j.net/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="security" scheme="http://michael-j.net/tags/security/"/>
    
  </entry>
  
</feed>
